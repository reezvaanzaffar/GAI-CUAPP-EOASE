"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/speakeasy";
exports.ids = ["vendor-chunks/speakeasy"];
exports.modules = {

/***/ "(rsc)/./node_modules/speakeasy/index.js":
/*!*****************************************!*\
  !*** ./node_modules/speakeasy/index.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nvar base32 = __webpack_require__(/*! base32.js */ \"(rsc)/./node_modules/base32.js/index.js\");\nvar crypto = __webpack_require__(/*! crypto */ \"crypto\");\nvar url = __webpack_require__(/*! url */ \"url\");\nvar util = __webpack_require__(/*! util */ \"util\");\n\n/**\n * Digest the one-time passcode options.\n *\n * @param {Object} options\n * @param {String} options.secret Shared secret key\n * @param {Integer} options.counter Counter value\n * @param {String} [options.encoding=\"ascii\"] Key encoding (ascii, hex,\n *   base32, base64).\n * @param {String} [options.algorithm=\"sha1\"] Hash algorithm (sha1, sha256,\n *   sha512).\n * @param {String} [options.key] (DEPRECATED. Use `secret` instead.)\n *   Shared secret key\n * @return {Buffer} The one-time passcode as a buffer.\n */\n\nexports.digest = function digest (options) {\n  var i;\n\n  // unpack options\n  var secret = options.secret;\n  var counter = options.counter;\n  var encoding = options.encoding || 'ascii';\n  var algorithm = (options.algorithm || 'sha1').toLowerCase();\n\n  // Backwards compatibility - deprecated\n  if (options.key != null) {\n    console.warn('Speakeasy - Deprecation Notice - Specifying the secret using `key` is no longer supported. Use `secret` instead.');\n    secret = options.key;\n  }\n\n  // convert secret to buffer\n  if (!Buffer.isBuffer(secret)) {\n    secret = encoding === 'base32' ? base32.decode(secret)\n      : new Buffer(secret, encoding);\n  }\n\n  // create an buffer from the counter\n  var buf = new Buffer(8);\n  var tmp = counter;\n  for (i = 0; i < 8; i++) {\n    // mask 0xff over number to get last 8\n    buf[7 - i] = tmp & 0xff;\n\n    // shift 8 and get ready to loop over the next batch of 8\n    tmp = tmp >> 8;\n  }\n\n  // init hmac with the key\n  var hmac = crypto.createHmac(algorithm, secret);\n\n  // update hmac with the counter\n  hmac.update(buf);\n\n  // return the digest\n  return hmac.digest();\n};\n\n/**\n * Generate a counter-based one-time token. Specify the key and counter, and\n * receive the one-time password for that counter position as a string. You can\n * also specify a token length, as well as the encoding (ASCII, hexadecimal, or\n * base32) and the hashing algorithm to use (SHA1, SHA256, SHA512).\n *\n * @param {Object} options\n * @param {String} options.secret Shared secret key\n * @param {Integer} options.counter Counter value\n * @param {Buffer} [options.digest] Digest, automatically generated by default\n * @param {Integer} [options.digits=6] The number of digits for the one-time\n *   passcode.\n * @param {String} [options.encoding=\"ascii\"] Key encoding (ascii, hex,\n *   base32, base64).\n * @param {String} [options.algorithm=\"sha1\"] Hash algorithm (sha1, sha256,\n *   sha512).\n * @param {String} [options.key] (DEPRECATED. Use `secret` instead.)\n *   Shared secret key\n * @param {Integer} [options.length=6] (DEPRECATED. Use `digits` instead.) The\n *   number of digits for the one-time passcode.\n * @return {String} The one-time passcode.\n */\n\nexports.hotp = function hotpGenerate (options) {\n  // unpack digits\n  // backward compatibility: `length` is also accepted here, but deprecated\n  var digits = (options.digits != null ? options.digits : options.length) || 6;\n  if (options.length != null) console.warn('Speakeasy - Deprecation Notice - Specifying token digits using `length` is no longer supported. Use `digits` instead.');\n\n  // digest the options\n  var digest = options.digest || exports.digest(options);\n\n  // compute HOTP offset\n  var offset = digest[digest.length - 1] & 0xf;\n\n  // calculate binary code (RFC4226 5.4)\n  var code = (digest[offset] & 0x7f) << 24 |\n    (digest[offset + 1] & 0xff) << 16 |\n    (digest[offset + 2] & 0xff) << 8 |\n    (digest[offset + 3] & 0xff);\n\n  // left-pad code\n  code = new Array(digits + 1).join('0') + code.toString(10);\n\n  // return length number off digits\n  return code.substr(-digits);\n};\n\n// Alias counter() for hotp()\nexports.counter = exports.hotp;\n\n/**\n * Verify a counter-based one-time token against the secret and return the delta.\n * By default, it verifies the token at the given counter value, with no leeway\n * (no look-ahead or look-behind). A token validated at the current counter value\n * will have a delta of 0.\n *\n * You can specify a window to add more leeway to the verification process.\n * Setting the window param will check for the token at the given counter value\n * as well as `window` tokens ahead (one-sided window). See param for more info.\n *\n * `verifyDelta()` will return the delta between the counter value of the token\n * and the given counter value. For example, if given a counter 5 and a window\n * 10, `verifyDelta()` will look at tokens from 5 to 15, inclusive. If it finds\n * it at counter position 7, it will return `{ delta: 2 }`.\n *\n * @param {Object} options\n * @param {String} options.secret Shared secret key\n * @param {String} options.token Passcode to validate\n * @param {Integer} options.counter Counter value. This should be stored by\n *   the application and must be incremented for each request.\n * @param {Integer} [options.digits=6] The number of digits for the one-time\n *   passcode.\n * @param {Integer} [options.window=0] The allowable margin for the counter.\n *   The function will check \"W\" codes in the future against the provided\n *   passcode, e.g. if W = 10, and C = 5, this function will check the\n *   passcode against all One Time Passcodes between 5 and 15, inclusive.\n * @param {String} [options.encoding=\"ascii\"] Key encoding (ascii, hex,\n *   base32, base64).\n * @param {String} [options.algorithm=\"sha1\"] Hash algorithm (sha1, sha256,\n *   sha512).\n * @return {Object} On success, returns an object with the counter\n *   difference between the client and the server as the `delta` property (i.e.\n *   `{ delta: 0 }`).\n * @method hotp己erifyDelta\n * @global\n */\n\nexports.hotp.verifyDelta = function hotpVerifyDelta (options) {\n  var i;\n\n  // shadow options\n  options = Object.create(options);\n\n  // unpack options\n  var token = String(options.token);\n  var digits = parseInt(options.digits, 10) || 6;\n  var window = parseInt(options.window, 10) || 0;\n  var counter = parseInt(options.counter, 10) || 0;\n\n  // fail if token is not of correct length\n  if (token.length !== digits) {\n    return;\n  }\n\n  // parse token to integer\n  token = parseInt(token, 10);\n\n  // fail if token is NA\n  if (isNaN(token)) {\n    return;\n  }\n\n  // loop from C to C + W inclusive\n  for (i = counter; i <= counter + window; ++i) {\n    options.counter = i;\n    // domain-specific constant-time comparison for integer codes\n    if (parseInt(exports.hotp(options), 10) === token) {\n      // found a matching code, return delta\n      return {delta: i - counter};\n    }\n  }\n\n  // no codes have matched\n};\n\n/**\n * Verify a counter-based one-time token against the secret and return true if\n * it verifies. Helper function for `hotp.verifyDelta()`` that returns a boolean\n * instead of an object. For more on how to use a window with this, see\n * {@link hotp.verifyDelta}.\n *\n * @param {Object} options\n * @param {String} options.secret Shared secret key\n * @param {String} options.token Passcode to validate\n * @param {Integer} options.counter Counter value. This should be stored by\n *   the application and must be incremented for each request.\n * @param {Integer} [options.digits=6] The number of digits for the one-time\n *   passcode.\n * @param {Integer} [options.window=0] The allowable margin for the counter.\n *   The function will check \"W\" codes in the future against the provided\n *   passcode, e.g. if W = 10, and C = 5, this function will check the\n *   passcode against all One Time Passcodes between 5 and 15, inclusive.\n * @param {String} [options.encoding=\"ascii\"] Key encoding (ascii, hex,\n *   base32, base64).\n * @param {String} [options.algorithm=\"sha1\"] Hash algorithm (sha1, sha256,\n *   sha512).\n * @return {Boolean} Returns true if the token matches within the given\n *   window, false otherwise.\n * @method hotp己erify\n * @global\n */\nexports.hotp.verify = function hotpVerify (options) {\n  return exports.hotp.verifyDelta(options) != null;\n};\n\n/**\n * Calculate counter value based on given options. A counter value converts a\n * TOTP time into a counter value by finding the number of time steps that have\n * passed since the epoch to the current time.\n *\n * @param {Object} options\n * @param {Integer} [options.time] Time in seconds with which to calculate\n *   counter value. Defaults to `Date.now()`.\n * @param {Integer} [options.step=30] Time step in seconds\n * @param {Integer} [options.epoch=0] Initial time since the UNIX epoch from\n *   which to calculate the counter value. Defaults to 0 (no offset).\n * @param {Integer} [options.initial_time=0] (DEPRECATED. Use `epoch` instead.)\n *   Initial time in seconds since the UNIX epoch from which to calculate the\n *   counter value. Defaults to 0 (no offset).\n * @return {Integer} The calculated counter value.\n * @private\n */\n\nexports._counter = function _counter (options) {\n  var step = options.step || 30;\n  var time = options.time != null ? (options.time * 1000) : Date.now();\n\n  // also accepts 'initial_time', but deprecated\n  var epoch = (options.epoch != null ? (options.epoch * 1000) : (options.initial_time * 1000)) || 0;\n  if (options.initial_time != null) console.warn('Speakeasy - Deprecation Notice - Specifying the epoch using `initial_time` is no longer supported. Use `epoch` instead.');\n\n  return Math.floor((time - epoch) / step / 1000);\n};\n\n/**\n * Generate a time-based one-time token. Specify the key, and receive the\n * one-time password for that time as a string. By default, it uses the current\n * time and a time step of 30 seconds, so there is a new token every 30 seconds.\n * You may override the time step and epoch for custom timing. You can also\n * specify a token length, as well as the encoding (ASCII, hexadecimal, or\n * base32) and the hashing algorithm to use (SHA1, SHA256, SHA512).\n *\n * Under the hood, TOTP calculates the counter value by finding how many time\n * steps have passed since the epoch, and calls HOTP with that counter value.\n *\n * @param {Object} options\n * @param {String} options.secret Shared secret key\n * @param {Integer} [options.time] Time in seconds with which to calculate\n *   counter value. Defaults to `Date.now()`.\n * @param {Integer} [options.step=30] Time step in seconds\n * @param {Integer} [options.epoch=0] Initial time in seconds since the UNIX\n *   epoch from which to calculate the counter value. Defaults to 0 (no offset).\n * @param {Integer} [options.counter] Counter value, calculated by default.\n * @param {Integer} [options.digits=6] The number of digits for the one-time\n *   passcode.\n * @param {String} [options.encoding=\"ascii\"] Key encoding (ascii, hex,\n *   base32, base64).\n * @param {String} [options.algorithm=\"sha1\"] Hash algorithm (sha1, sha256,\n *   sha512).\n * @param {String} [options.key] (DEPRECATED. Use `secret` instead.)\n *   Shared secret key\n * @param {Integer} [options.initial_time=0] (DEPRECATED. Use `epoch` instead.)\n *   Initial time in seconds since the UNIX epoch from which to calculate the\n *   counter value. Defaults to 0 (no offset).\n * @param {Integer} [options.length=6] (DEPRECATED. Use `digits` instead.) The\n *   number of digits for the one-time passcode.\n * @return {String} The one-time passcode.\n */\n\nexports.totp = function totpGenerate (options) {\n  // shadow options\n  options = Object.create(options);\n\n  // calculate default counter value\n  if (options.counter == null) options.counter = exports._counter(options);\n\n  // pass to hotp\n  return this.hotp(options);\n};\n\n// Alias time() for totp()\nexports.time = exports.totp;\n\n/**\n * Verify a time-based one-time token against the secret and return the delta.\n * By default, it verifies the token at the current time window, with no leeway\n * (no look-ahead or look-behind). A token validated at the current time window\n * will have a delta of 0.\n *\n * You can specify a window to add more leeway to the verification process.\n * Setting the window param will check for the token at the given counter value\n * as well as `window` tokens ahead and `window` tokens behind (two-sided\n * window). See param for more info.\n *\n * `verifyDelta()` will return the delta between the counter value of the token\n * and the given counter value. For example, if given a time at counter 1000 and\n * a window of 5, `verifyDelta()` will look at tokens from 995 to 1005,\n * inclusive. In other words, if the time-step is 30 seconds, it will look at\n * tokens from 2.5 minutes ago to 2.5 minutes in the future, inclusive.\n * If it finds it at counter position 1002, it will return `{ delta: 2 }`.\n * If it finds it at counter position 997, it will return `{ delta: -3 }`.\n *\n * @param {Object} options\n * @param {String} options.secret Shared secret key\n * @param {String} options.token Passcode to validate\n * @param {Integer} [options.time] Time in seconds with which to calculate\n *   counter value. Defaults to `Date.now()`.\n * @param {Integer} [options.step=30] Time step in seconds\n * @param {Integer} [options.epoch=0] Initial time in seconds since the UNIX\n *   epoch from which to calculate the counter value. Defaults to 0 (no offset).\n * @param {Integer} [options.counter] Counter value, calculated by default.\n * @param {Integer} [options.digits=6] The number of digits for the one-time\n *   passcode.\n * @param {Integer} [options.window=0] The allowable margin for the counter.\n *   The function will check \"W\" codes in the future and the past against the\n *   provided passcode, e.g. if W = 5, and C = 1000, this function will check\n *   the passcode against all One Time Passcodes between 995 and 1005,\n *   inclusive.\n * @param {String} [options.encoding=\"ascii\"] Key encoding (ascii, hex,\n *   base32, base64).\n * @param {String} [options.algorithm=\"sha1\"] Hash algorithm (sha1, sha256,\n *   sha512).\n * @return {Object} On success, returns an object with the time step\n *   difference between the client and the server as the `delta` property (e.g.\n *   `{ delta: 0 }`).\n * @method totp己erifyDelta\n * @global\n */\n\nexports.totp.verifyDelta = function totpVerifyDelta (options) {\n  // shadow options\n  options = Object.create(options);\n\n  // unpack options\n  var window = parseInt(options.window, 10) || 0;\n\n  // calculate default counter value\n  if (options.counter == null) options.counter = exports._counter(options);\n\n  // adjust for two-sided window\n  options.counter -= window;\n  options.window += window;\n\n  // pass to hotp.verifyDelta\n  var delta = exports.hotp.verifyDelta(options);\n\n  // adjust for two-sided window\n  if (delta) {\n    delta.delta -= window;\n  }\n\n  return delta;\n};\n\n/**\n * Verify a time-based one-time token against the secret and return true if it\n * verifies. Helper function for verifyDelta() that returns a boolean instead of\n * an object. For more on how to use a window with this, see\n * {@link totp.verifyDelta}.\n *\n * @param {Object} options\n * @param {String} options.secret Shared secret key\n * @param {String} options.token Passcode to validate\n * @param {Integer} [options.time] Time in seconds with which to calculate\n *   counter value. Defaults to `Date.now()`.\n * @param {Integer} [options.step=30] Time step in seconds\n * @param {Integer} [options.epoch=0] Initial time in seconds  since the UNIX\n *   epoch from which to calculate the counter value. Defaults to 0 (no offset).\n * @param {Integer} [options.counter] Counter value, calculated by default.\n * @param {Integer} [options.digits=6] The number of digits for the one-time\n *   passcode.\n * @param {Integer} [options.window=0] The allowable margin for the counter.\n *   The function will check \"W\" codes in the future and the past against the\n *   provided passcode, e.g. if W = 5, and C = 1000, this function will check\n *   the passcode against all One Time Passcodes between 995 and 1005,\n *   inclusive.\n * @param {String} [options.encoding=\"ascii\"] Key encoding (ascii, hex,\n *   base32, base64).\n * @param {String} [options.algorithm=\"sha1\"] Hash algorithm (sha1, sha256,\n *   sha512).\n * @return {Boolean} Returns true if the token matches within the given\n *   window, false otherwise.\n * @method totp己erify\n * @global\n */\nexports.totp.verify = function totpVerify (options) {\n  return exports.totp.verifyDelta(options) != null;\n};\n\n/**\n * @typedef GeneratedSecret\n * @type Object\n * @property {String} ascii ASCII representation of the secret\n * @property {String} hex Hex representation of the secret\n * @property {String} base32 Base32 representation of the secret\n * @property {String} qr_code_ascii URL for the QR code for the ASCII secret.\n * @property {String} qr_code_hex URL for the QR code for the hex secret.\n * @property {String} qr_code_base32 URL for the QR code for the base32 secret.\n * @property {String} google_auth_qr URL for the Google Authenticator otpauth\n *   URL's QR code.\n * @property {String} otpauth_url Google Authenticator-compatible otpauth URL.\n */\n\n/**\n * Generates a random secret with the set A-Z a-z 0-9 and symbols, of any length\n * (default 32). Returns the secret key in ASCII, hexadecimal, and base32 format,\n * along with the URL used for the QR code for Google Authenticator (an otpauth\n * URL). Use a QR code library to generate a QR code based on the Google\n * Authenticator URL to obtain a QR code you can scan into the app.\n *\n * @param {Object} options\n * @param {Integer} [options.length=32] Length of the secret\n * @param {Boolean} [options.symbols=false] Whether to include symbols\n * @param {Boolean} [options.otpauth_url=true] Whether to output a Google\n *   Authenticator-compatible otpauth:// URL (only returns otpauth:// URL, no\n *   QR code)\n * @param {String} [options.name] The name to use with Google Authenticator.\n * @param {Boolean} [options.qr_codes=false] (DEPRECATED. Do not use to prevent\n *   leaking of secret to a third party. Use your own QR code implementation.)\n *   Output QR code URLs for the token.\n * @param {Boolean} [options.google_auth_qr=false] (DEPRECATED. Do not use to\n *   prevent leaking of secret to a third party. Use your own QR code\n *   implementation.) Output a Google Authenticator otpauth:// QR code URL.\n * @return {Object}\n * @return {GeneratedSecret} The generated secret key.\n */\nexports.generateSecret = function generateSecret (options) {\n  // options\n  if (!options) options = {};\n  var length = options.length || 32;\n  var name = encodeURIComponent(options.name || 'SecretKey');\n  var qr_codes = options.qr_codes || false;\n  var google_auth_qr = options.google_auth_qr || false;\n  var otpauth_url = options.otpauth_url != null ? options.otpauth_url : true;\n  var symbols = true;\n\n  // turn off symbols only when explicity told to\n  if (options.symbols !== undefined && options.symbols === false) {\n    symbols = false;\n  }\n\n  // generate an ascii key\n  var key = this.generateSecretASCII(length, symbols);\n\n  // return a SecretKey with ascii, hex, and base32\n  var SecretKey = {};\n  SecretKey.ascii = key;\n  SecretKey.hex = Buffer(key, 'ascii').toString('hex');\n  SecretKey.base32 = base32.encode(Buffer(key)).toString().replace(/=/g, '');\n\n  // generate some qr codes if requested\n  if (qr_codes) {\n    console.warn('Speakeasy - Deprecation Notice - generateSecret() QR codes are deprecated and no longer supported. Please use your own QR code implementation.');\n    SecretKey.qr_code_ascii = 'https://chart.googleapis.com/chart?chs=166x166&chld=L|0&cht=qr&chl=' + encodeURIComponent(SecretKey.ascii);\n    SecretKey.qr_code_hex = 'https://chart.googleapis.com/chart?chs=166x166&chld=L|0&cht=qr&chl=' + encodeURIComponent(SecretKey.hex);\n    SecretKey.qr_code_base32 = 'https://chart.googleapis.com/chart?chs=166x166&chld=L|0&cht=qr&chl=' + encodeURIComponent(SecretKey.base32);\n  }\n\n  // add in the Google Authenticator-compatible otpauth URL\n  if (otpauth_url) {\n    SecretKey.otpauth_url = exports.otpauthURL({\n      secret: SecretKey.ascii,\n      label: name\n    });\n  }\n\n  // generate a QR code for use in Google Authenticator if requested\n  if (google_auth_qr) {\n    console.warn('Speakeasy - Deprecation Notice - generateSecret() Google Auth QR code is deprecated and no longer supported. Please use your own QR code implementation.');\n    SecretKey.google_auth_qr = 'https://chart.googleapis.com/chart?chs=166x166&chld=L|0&cht=qr&chl=' + encodeURIComponent(exports.otpauthURL({ secret: SecretKey.base32, label: name }));\n  }\n\n  return SecretKey;\n};\n\n// Backwards compatibility - generate_key is deprecated\nexports.generate_key = util.deprecate(function (options) {\n  return exports.generateSecret(options);\n}, 'Speakeasy - Deprecation Notice - `generate_key()` is depreciated, please use `generateSecret()` instead.');\n\n/**\n * Generates a key of a certain length (default 32) from A-Z, a-z, 0-9, and\n * symbols (if requested).\n *\n * @param  {Integer} [length=32]  The length of the key.\n * @param  {Boolean} [symbols=false] Whether to include symbols in the key.\n * @return {String} The generated key.\n */\nexports.generateSecretASCII = function generateSecretASCII (length, symbols) {\n  var bytes = crypto.randomBytes(length || 32);\n  var set = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXTZabcdefghiklmnopqrstuvwxyz';\n  if (symbols) {\n    set += '!@#$%^&*()<>?/[]{},.:;';\n  }\n\n  var output = '';\n  for (var i = 0, l = bytes.length; i < l; i++) {\n    output += set[Math.floor(bytes[i] / 255.0 * (set.length - 1))];\n  }\n  return output;\n};\n\n// Backwards compatibility - generate_key_ascii is deprecated\nexports.generate_key_ascii = util.deprecate(function (length, symbols) {\n  return exports.generateSecretASCII(length, symbols);\n}, 'Speakeasy - Deprecation Notice - `generate_key_ascii()` is depreciated, please use `generateSecretASCII()` instead.');\n\n/**\n * Generate a Google Authenticator-compatible otpauth:// URL for passing the\n * secret to a mobile device to install the secret.\n *\n * Authenticator considers TOTP codes valid for 30 seconds. Additionally,\n * the app presents 6 digits codes to the user. According to the\n * documentation, the period and number of digits are currently ignored by\n * the app.\n *\n * To generate a suitable QR Code, pass the generated URL to a QR Code\n * generator, such as the `qr-image` module.\n *\n * @param {Object} options\n * @param {String} options.secret Shared secret key\n * @param {String} options.label Used to identify the account with which\n *   the secret key is associated, e.g. the user's email address.\n * @param {String} [options.type=\"totp\"] Either \"hotp\" or \"totp\".\n * @param {Integer} [options.counter] The initial counter value, required\n *   for HOTP.\n * @param {String} [options.issuer] The provider or service with which the\n *   secret key is associated.\n * @param {String} [options.algorithm=\"sha1\"] Hash algorithm (sha1, sha256,\n *   sha512).\n * @param {Integer} [options.digits=6] The number of digits for the one-time\n *   passcode. Currently ignored by Google Authenticator.\n * @param {Integer} [options.period=30] The length of time for which a TOTP\n *   code will be valid, in seconds. Currently ignored by Google\n *   Authenticator.\n * @param {String} [options.encoding] Key encoding (ascii, hex, base32,\n *   base64). If the key is not encoded in Base-32, it will be reencoded.\n * @return {String} A URL suitable for use with the Google Authenticator.\n * @throws Error if secret or label is missing, or if hotp is used and a\n    counter is missing, if the type is not one of `hotp` or `totp`, if the\n    number of digits is non-numeric, or an invalid period is used. Warns if\n    the number of digits is not either 6 or 8 (though 6 is the only one\n    supported by Google Authenticator), and if the hashihng algorithm is\n    not one of the supported SHA1, SHA256, or SHA512.\n * @see https://github.com/google/google-authenticator/wiki/Key-Uri-Format\n */\n\nexports.otpauthURL = function otpauthURL (options) {\n  // unpack options\n  var secret = options.secret;\n  var label = options.label;\n  var issuer = options.issuer;\n  var type = (options.type || 'totp').toLowerCase();\n  var counter = options.counter;\n  var algorithm = options.algorithm;\n  var digits = options.digits;\n  var period = options.period;\n  var encoding = options.encoding || 'ascii';\n\n  // validate type\n  switch (type) {\n    case 'totp':\n    case 'hotp':\n      break;\n    default:\n      throw new Error('Speakeasy - otpauthURL - Invalid type `' + type + '`; must be `hotp` or `totp`');\n  }\n\n  // validate required options\n  if (!secret) throw new Error('Speakeasy - otpauthURL - Missing secret');\n  if (!label) throw new Error('Speakeasy - otpauthURL - Missing label');\n\n  // require counter for HOTP\n  if (type === 'hotp' && (counter === null || typeof counter === 'undefined')) {\n    throw new Error('Speakeasy - otpauthURL - Missing counter value for HOTP');\n  }\n\n  // convert secret to base32\n  if (encoding !== 'base32') secret = new Buffer(secret, encoding);\n  if (Buffer.isBuffer(secret)) secret = base32.encode(secret);\n\n  // build query while validating\n  var query = {secret: secret};\n  if (issuer) query.issuer = issuer;\n\n  // validate algorithm\n  if (algorithm != null) {\n    switch (algorithm.toUpperCase()) {\n      case 'SHA1':\n      case 'SHA256':\n      case 'SHA512':\n        break;\n      default:\n        console.warn('Speakeasy - otpauthURL - Warning - Algorithm generally should be SHA1, SHA256, or SHA512');\n    }\n    query.algorithm = algorithm.toUpperCase();\n  }\n\n  // validate digits\n  if (digits != null) {\n    if (isNaN(digits)) {\n      throw new Error('Speakeasy - otpauthURL - Invalid digits `' + digits + '`');\n    } else {\n      switch (parseInt(digits, 10)) {\n        case 6:\n        case 8:\n          break;\n        default:\n          console.warn('Speakeasy - otpauthURL - Warning - Digits generally should be either 6 or 8');\n      }\n    }\n    query.digits = digits;\n  }\n\n  // validate period\n  if (period != null) {\n    period = parseInt(period, 10);\n    if (~~period !== period) {\n      throw new Error('Speakeasy - otpauthURL - Invalid period `' + period + '`');\n    }\n    query.period = period;\n  }\n\n  // return url\n  return url.format({\n    protocol: 'otpauth',\n    slashes: true,\n    hostname: type,\n    pathname: label,\n    query: query\n  });\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc3BlYWtlYXN5L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLGFBQWEsbUJBQU8sQ0FBQywwREFBVztBQUNoQyxhQUFhLG1CQUFPLENBQUMsc0JBQVE7QUFDN0IsVUFBVSxtQkFBTyxDQUFDLGdCQUFLO0FBQ3ZCLFdBQVcsbUJBQU8sQ0FBQyxrQkFBTTs7QUFFekI7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCOztBQUVBLGNBQWM7QUFDZDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCOztBQUVBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWU7O0FBRWY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lY29tbWVyY2Utb3V0c2V0Ly4vbm9kZV9tb2R1bGVzL3NwZWFrZWFzeS9pbmRleC5qcz80ZTZkIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIGJhc2UzMiA9IHJlcXVpcmUoJ2Jhc2UzMi5qcycpO1xudmFyIGNyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpO1xudmFyIHVybCA9IHJlcXVpcmUoJ3VybCcpO1xudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG5cbi8qKlxuICogRGlnZXN0IHRoZSBvbmUtdGltZSBwYXNzY29kZSBvcHRpb25zLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy5zZWNyZXQgU2hhcmVkIHNlY3JldCBrZXlcbiAqIEBwYXJhbSB7SW50ZWdlcn0gb3B0aW9ucy5jb3VudGVyIENvdW50ZXIgdmFsdWVcbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5lbmNvZGluZz1cImFzY2lpXCJdIEtleSBlbmNvZGluZyAoYXNjaWksIGhleCxcbiAqICAgYmFzZTMyLCBiYXNlNjQpLlxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFsZ29yaXRobT1cInNoYTFcIl0gSGFzaCBhbGdvcml0aG0gKHNoYTEsIHNoYTI1NixcbiAqICAgc2hhNTEyKS5cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5rZXldIChERVBSRUNBVEVELiBVc2UgYHNlY3JldGAgaW5zdGVhZC4pXG4gKiAgIFNoYXJlZCBzZWNyZXQga2V5XG4gKiBAcmV0dXJuIHtCdWZmZXJ9IFRoZSBvbmUtdGltZSBwYXNzY29kZSBhcyBhIGJ1ZmZlci5cbiAqL1xuXG5leHBvcnRzLmRpZ2VzdCA9IGZ1bmN0aW9uIGRpZ2VzdCAob3B0aW9ucykge1xuICB2YXIgaTtcblxuICAvLyB1bnBhY2sgb3B0aW9uc1xuICB2YXIgc2VjcmV0ID0gb3B0aW9ucy5zZWNyZXQ7XG4gIHZhciBjb3VudGVyID0gb3B0aW9ucy5jb3VudGVyO1xuICB2YXIgZW5jb2RpbmcgPSBvcHRpb25zLmVuY29kaW5nIHx8ICdhc2NpaSc7XG4gIHZhciBhbGdvcml0aG0gPSAob3B0aW9ucy5hbGdvcml0aG0gfHwgJ3NoYTEnKS50b0xvd2VyQ2FzZSgpO1xuXG4gIC8vIEJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IC0gZGVwcmVjYXRlZFxuICBpZiAob3B0aW9ucy5rZXkgIT0gbnVsbCkge1xuICAgIGNvbnNvbGUud2FybignU3BlYWtlYXN5IC0gRGVwcmVjYXRpb24gTm90aWNlIC0gU3BlY2lmeWluZyB0aGUgc2VjcmV0IHVzaW5nIGBrZXlgIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQuIFVzZSBgc2VjcmV0YCBpbnN0ZWFkLicpO1xuICAgIHNlY3JldCA9IG9wdGlvbnMua2V5O1xuICB9XG5cbiAgLy8gY29udmVydCBzZWNyZXQgdG8gYnVmZmVyXG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHNlY3JldCkpIHtcbiAgICBzZWNyZXQgPSBlbmNvZGluZyA9PT0gJ2Jhc2UzMicgPyBiYXNlMzIuZGVjb2RlKHNlY3JldClcbiAgICAgIDogbmV3IEJ1ZmZlcihzZWNyZXQsIGVuY29kaW5nKTtcbiAgfVxuXG4gIC8vIGNyZWF0ZSBhbiBidWZmZXIgZnJvbSB0aGUgY291bnRlclxuICB2YXIgYnVmID0gbmV3IEJ1ZmZlcig4KTtcbiAgdmFyIHRtcCA9IGNvdW50ZXI7XG4gIGZvciAoaSA9IDA7IGkgPCA4OyBpKyspIHtcbiAgICAvLyBtYXNrIDB4ZmYgb3ZlciBudW1iZXIgdG8gZ2V0IGxhc3QgOFxuICAgIGJ1Zls3IC0gaV0gPSB0bXAgJiAweGZmO1xuXG4gICAgLy8gc2hpZnQgOCBhbmQgZ2V0IHJlYWR5IHRvIGxvb3Agb3ZlciB0aGUgbmV4dCBiYXRjaCBvZiA4XG4gICAgdG1wID0gdG1wID4+IDg7XG4gIH1cblxuICAvLyBpbml0IGhtYWMgd2l0aCB0aGUga2V5XG4gIHZhciBobWFjID0gY3J5cHRvLmNyZWF0ZUhtYWMoYWxnb3JpdGhtLCBzZWNyZXQpO1xuXG4gIC8vIHVwZGF0ZSBobWFjIHdpdGggdGhlIGNvdW50ZXJcbiAgaG1hYy51cGRhdGUoYnVmKTtcblxuICAvLyByZXR1cm4gdGhlIGRpZ2VzdFxuICByZXR1cm4gaG1hYy5kaWdlc3QoKTtcbn07XG5cbi8qKlxuICogR2VuZXJhdGUgYSBjb3VudGVyLWJhc2VkIG9uZS10aW1lIHRva2VuLiBTcGVjaWZ5IHRoZSBrZXkgYW5kIGNvdW50ZXIsIGFuZFxuICogcmVjZWl2ZSB0aGUgb25lLXRpbWUgcGFzc3dvcmQgZm9yIHRoYXQgY291bnRlciBwb3NpdGlvbiBhcyBhIHN0cmluZy4gWW91IGNhblxuICogYWxzbyBzcGVjaWZ5IGEgdG9rZW4gbGVuZ3RoLCBhcyB3ZWxsIGFzIHRoZSBlbmNvZGluZyAoQVNDSUksIGhleGFkZWNpbWFsLCBvclxuICogYmFzZTMyKSBhbmQgdGhlIGhhc2hpbmcgYWxnb3JpdGhtIHRvIHVzZSAoU0hBMSwgU0hBMjU2LCBTSEE1MTIpLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy5zZWNyZXQgU2hhcmVkIHNlY3JldCBrZXlcbiAqIEBwYXJhbSB7SW50ZWdlcn0gb3B0aW9ucy5jb3VudGVyIENvdW50ZXIgdmFsdWVcbiAqIEBwYXJhbSB7QnVmZmVyfSBbb3B0aW9ucy5kaWdlc3RdIERpZ2VzdCwgYXV0b21hdGljYWxseSBnZW5lcmF0ZWQgYnkgZGVmYXVsdFxuICogQHBhcmFtIHtJbnRlZ2VyfSBbb3B0aW9ucy5kaWdpdHM9Nl0gVGhlIG51bWJlciBvZiBkaWdpdHMgZm9yIHRoZSBvbmUtdGltZVxuICogICBwYXNzY29kZS5cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5lbmNvZGluZz1cImFzY2lpXCJdIEtleSBlbmNvZGluZyAoYXNjaWksIGhleCxcbiAqICAgYmFzZTMyLCBiYXNlNjQpLlxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFsZ29yaXRobT1cInNoYTFcIl0gSGFzaCBhbGdvcml0aG0gKHNoYTEsIHNoYTI1NixcbiAqICAgc2hhNTEyKS5cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5rZXldIChERVBSRUNBVEVELiBVc2UgYHNlY3JldGAgaW5zdGVhZC4pXG4gKiAgIFNoYXJlZCBzZWNyZXQga2V5XG4gKiBAcGFyYW0ge0ludGVnZXJ9IFtvcHRpb25zLmxlbmd0aD02XSAoREVQUkVDQVRFRC4gVXNlIGBkaWdpdHNgIGluc3RlYWQuKSBUaGVcbiAqICAgbnVtYmVyIG9mIGRpZ2l0cyBmb3IgdGhlIG9uZS10aW1lIHBhc3Njb2RlLlxuICogQHJldHVybiB7U3RyaW5nfSBUaGUgb25lLXRpbWUgcGFzc2NvZGUuXG4gKi9cblxuZXhwb3J0cy5ob3RwID0gZnVuY3Rpb24gaG90cEdlbmVyYXRlIChvcHRpb25zKSB7XG4gIC8vIHVucGFjayBkaWdpdHNcbiAgLy8gYmFja3dhcmQgY29tcGF0aWJpbGl0eTogYGxlbmd0aGAgaXMgYWxzbyBhY2NlcHRlZCBoZXJlLCBidXQgZGVwcmVjYXRlZFxuICB2YXIgZGlnaXRzID0gKG9wdGlvbnMuZGlnaXRzICE9IG51bGwgPyBvcHRpb25zLmRpZ2l0cyA6IG9wdGlvbnMubGVuZ3RoKSB8fCA2O1xuICBpZiAob3B0aW9ucy5sZW5ndGggIT0gbnVsbCkgY29uc29sZS53YXJuKCdTcGVha2Vhc3kgLSBEZXByZWNhdGlvbiBOb3RpY2UgLSBTcGVjaWZ5aW5nIHRva2VuIGRpZ2l0cyB1c2luZyBgbGVuZ3RoYCBpcyBubyBsb25nZXIgc3VwcG9ydGVkLiBVc2UgYGRpZ2l0c2AgaW5zdGVhZC4nKTtcblxuICAvLyBkaWdlc3QgdGhlIG9wdGlvbnNcbiAgdmFyIGRpZ2VzdCA9IG9wdGlvbnMuZGlnZXN0IHx8IGV4cG9ydHMuZGlnZXN0KG9wdGlvbnMpO1xuXG4gIC8vIGNvbXB1dGUgSE9UUCBvZmZzZXRcbiAgdmFyIG9mZnNldCA9IGRpZ2VzdFtkaWdlc3QubGVuZ3RoIC0gMV0gJiAweGY7XG5cbiAgLy8gY2FsY3VsYXRlIGJpbmFyeSBjb2RlIChSRkM0MjI2IDUuNClcbiAgdmFyIGNvZGUgPSAoZGlnZXN0W29mZnNldF0gJiAweDdmKSA8PCAyNCB8XG4gICAgKGRpZ2VzdFtvZmZzZXQgKyAxXSAmIDB4ZmYpIDw8IDE2IHxcbiAgICAoZGlnZXN0W29mZnNldCArIDJdICYgMHhmZikgPDwgOCB8XG4gICAgKGRpZ2VzdFtvZmZzZXQgKyAzXSAmIDB4ZmYpO1xuXG4gIC8vIGxlZnQtcGFkIGNvZGVcbiAgY29kZSA9IG5ldyBBcnJheShkaWdpdHMgKyAxKS5qb2luKCcwJykgKyBjb2RlLnRvU3RyaW5nKDEwKTtcblxuICAvLyByZXR1cm4gbGVuZ3RoIG51bWJlciBvZmYgZGlnaXRzXG4gIHJldHVybiBjb2RlLnN1YnN0cigtZGlnaXRzKTtcbn07XG5cbi8vIEFsaWFzIGNvdW50ZXIoKSBmb3IgaG90cCgpXG5leHBvcnRzLmNvdW50ZXIgPSBleHBvcnRzLmhvdHA7XG5cbi8qKlxuICogVmVyaWZ5IGEgY291bnRlci1iYXNlZCBvbmUtdGltZSB0b2tlbiBhZ2FpbnN0IHRoZSBzZWNyZXQgYW5kIHJldHVybiB0aGUgZGVsdGEuXG4gKiBCeSBkZWZhdWx0LCBpdCB2ZXJpZmllcyB0aGUgdG9rZW4gYXQgdGhlIGdpdmVuIGNvdW50ZXIgdmFsdWUsIHdpdGggbm8gbGVld2F5XG4gKiAobm8gbG9vay1haGVhZCBvciBsb29rLWJlaGluZCkuIEEgdG9rZW4gdmFsaWRhdGVkIGF0IHRoZSBjdXJyZW50IGNvdW50ZXIgdmFsdWVcbiAqIHdpbGwgaGF2ZSBhIGRlbHRhIG9mIDAuXG4gKlxuICogWW91IGNhbiBzcGVjaWZ5IGEgd2luZG93IHRvIGFkZCBtb3JlIGxlZXdheSB0byB0aGUgdmVyaWZpY2F0aW9uIHByb2Nlc3MuXG4gKiBTZXR0aW5nIHRoZSB3aW5kb3cgcGFyYW0gd2lsbCBjaGVjayBmb3IgdGhlIHRva2VuIGF0IHRoZSBnaXZlbiBjb3VudGVyIHZhbHVlXG4gKiBhcyB3ZWxsIGFzIGB3aW5kb3dgIHRva2VucyBhaGVhZCAob25lLXNpZGVkIHdpbmRvdykuIFNlZSBwYXJhbSBmb3IgbW9yZSBpbmZvLlxuICpcbiAqIGB2ZXJpZnlEZWx0YSgpYCB3aWxsIHJldHVybiB0aGUgZGVsdGEgYmV0d2VlbiB0aGUgY291bnRlciB2YWx1ZSBvZiB0aGUgdG9rZW5cbiAqIGFuZCB0aGUgZ2l2ZW4gY291bnRlciB2YWx1ZS4gRm9yIGV4YW1wbGUsIGlmIGdpdmVuIGEgY291bnRlciA1IGFuZCBhIHdpbmRvd1xuICogMTAsIGB2ZXJpZnlEZWx0YSgpYCB3aWxsIGxvb2sgYXQgdG9rZW5zIGZyb20gNSB0byAxNSwgaW5jbHVzaXZlLiBJZiBpdCBmaW5kc1xuICogaXQgYXQgY291bnRlciBwb3NpdGlvbiA3LCBpdCB3aWxsIHJldHVybiBgeyBkZWx0YTogMiB9YC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMuc2VjcmV0IFNoYXJlZCBzZWNyZXQga2V5XG4gKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy50b2tlbiBQYXNzY29kZSB0byB2YWxpZGF0ZVxuICogQHBhcmFtIHtJbnRlZ2VyfSBvcHRpb25zLmNvdW50ZXIgQ291bnRlciB2YWx1ZS4gVGhpcyBzaG91bGQgYmUgc3RvcmVkIGJ5XG4gKiAgIHRoZSBhcHBsaWNhdGlvbiBhbmQgbXVzdCBiZSBpbmNyZW1lbnRlZCBmb3IgZWFjaCByZXF1ZXN0LlxuICogQHBhcmFtIHtJbnRlZ2VyfSBbb3B0aW9ucy5kaWdpdHM9Nl0gVGhlIG51bWJlciBvZiBkaWdpdHMgZm9yIHRoZSBvbmUtdGltZVxuICogICBwYXNzY29kZS5cbiAqIEBwYXJhbSB7SW50ZWdlcn0gW29wdGlvbnMud2luZG93PTBdIFRoZSBhbGxvd2FibGUgbWFyZ2luIGZvciB0aGUgY291bnRlci5cbiAqICAgVGhlIGZ1bmN0aW9uIHdpbGwgY2hlY2sgXCJXXCIgY29kZXMgaW4gdGhlIGZ1dHVyZSBhZ2FpbnN0IHRoZSBwcm92aWRlZFxuICogICBwYXNzY29kZSwgZS5nLiBpZiBXID0gMTAsIGFuZCBDID0gNSwgdGhpcyBmdW5jdGlvbiB3aWxsIGNoZWNrIHRoZVxuICogICBwYXNzY29kZSBhZ2FpbnN0IGFsbCBPbmUgVGltZSBQYXNzY29kZXMgYmV0d2VlbiA1IGFuZCAxNSwgaW5jbHVzaXZlLlxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmVuY29kaW5nPVwiYXNjaWlcIl0gS2V5IGVuY29kaW5nIChhc2NpaSwgaGV4LFxuICogICBiYXNlMzIsIGJhc2U2NCkuXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYWxnb3JpdGhtPVwic2hhMVwiXSBIYXNoIGFsZ29yaXRobSAoc2hhMSwgc2hhMjU2LFxuICogICBzaGE1MTIpLlxuICogQHJldHVybiB7T2JqZWN0fSBPbiBzdWNjZXNzLCByZXR1cm5zIGFuIG9iamVjdCB3aXRoIHRoZSBjb3VudGVyXG4gKiAgIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGUgY2xpZW50IGFuZCB0aGUgc2VydmVyIGFzIHRoZSBgZGVsdGFgIHByb3BlcnR5IChpLmUuXG4gKiAgIGB7IGRlbHRhOiAwIH1gKS5cbiAqIEBtZXRob2QgaG90cOKApHZlcmlmeURlbHRhXG4gKiBAZ2xvYmFsXG4gKi9cblxuZXhwb3J0cy5ob3RwLnZlcmlmeURlbHRhID0gZnVuY3Rpb24gaG90cFZlcmlmeURlbHRhIChvcHRpb25zKSB7XG4gIHZhciBpO1xuXG4gIC8vIHNoYWRvdyBvcHRpb25zXG4gIG9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKG9wdGlvbnMpO1xuXG4gIC8vIHVucGFjayBvcHRpb25zXG4gIHZhciB0b2tlbiA9IFN0cmluZyhvcHRpb25zLnRva2VuKTtcbiAgdmFyIGRpZ2l0cyA9IHBhcnNlSW50KG9wdGlvbnMuZGlnaXRzLCAxMCkgfHwgNjtcbiAgdmFyIHdpbmRvdyA9IHBhcnNlSW50KG9wdGlvbnMud2luZG93LCAxMCkgfHwgMDtcbiAgdmFyIGNvdW50ZXIgPSBwYXJzZUludChvcHRpb25zLmNvdW50ZXIsIDEwKSB8fCAwO1xuXG4gIC8vIGZhaWwgaWYgdG9rZW4gaXMgbm90IG9mIGNvcnJlY3QgbGVuZ3RoXG4gIGlmICh0b2tlbi5sZW5ndGggIT09IGRpZ2l0cykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIHBhcnNlIHRva2VuIHRvIGludGVnZXJcbiAgdG9rZW4gPSBwYXJzZUludCh0b2tlbiwgMTApO1xuXG4gIC8vIGZhaWwgaWYgdG9rZW4gaXMgTkFcbiAgaWYgKGlzTmFOKHRva2VuKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIGxvb3AgZnJvbSBDIHRvIEMgKyBXIGluY2x1c2l2ZVxuICBmb3IgKGkgPSBjb3VudGVyOyBpIDw9IGNvdW50ZXIgKyB3aW5kb3c7ICsraSkge1xuICAgIG9wdGlvbnMuY291bnRlciA9IGk7XG4gICAgLy8gZG9tYWluLXNwZWNpZmljIGNvbnN0YW50LXRpbWUgY29tcGFyaXNvbiBmb3IgaW50ZWdlciBjb2Rlc1xuICAgIGlmIChwYXJzZUludChleHBvcnRzLmhvdHAob3B0aW9ucyksIDEwKSA9PT0gdG9rZW4pIHtcbiAgICAgIC8vIGZvdW5kIGEgbWF0Y2hpbmcgY29kZSwgcmV0dXJuIGRlbHRhXG4gICAgICByZXR1cm4ge2RlbHRhOiBpIC0gY291bnRlcn07XG4gICAgfVxuICB9XG5cbiAgLy8gbm8gY29kZXMgaGF2ZSBtYXRjaGVkXG59O1xuXG4vKipcbiAqIFZlcmlmeSBhIGNvdW50ZXItYmFzZWQgb25lLXRpbWUgdG9rZW4gYWdhaW5zdCB0aGUgc2VjcmV0IGFuZCByZXR1cm4gdHJ1ZSBpZlxuICogaXQgdmVyaWZpZXMuIEhlbHBlciBmdW5jdGlvbiBmb3IgYGhvdHAudmVyaWZ5RGVsdGEoKWBgIHRoYXQgcmV0dXJucyBhIGJvb2xlYW5cbiAqIGluc3RlYWQgb2YgYW4gb2JqZWN0LiBGb3IgbW9yZSBvbiBob3cgdG8gdXNlIGEgd2luZG93IHdpdGggdGhpcywgc2VlXG4gKiB7QGxpbmsgaG90cC52ZXJpZnlEZWx0YX0uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLnNlY3JldCBTaGFyZWQgc2VjcmV0IGtleVxuICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMudG9rZW4gUGFzc2NvZGUgdG8gdmFsaWRhdGVcbiAqIEBwYXJhbSB7SW50ZWdlcn0gb3B0aW9ucy5jb3VudGVyIENvdW50ZXIgdmFsdWUuIFRoaXMgc2hvdWxkIGJlIHN0b3JlZCBieVxuICogICB0aGUgYXBwbGljYXRpb24gYW5kIG11c3QgYmUgaW5jcmVtZW50ZWQgZm9yIGVhY2ggcmVxdWVzdC5cbiAqIEBwYXJhbSB7SW50ZWdlcn0gW29wdGlvbnMuZGlnaXRzPTZdIFRoZSBudW1iZXIgb2YgZGlnaXRzIGZvciB0aGUgb25lLXRpbWVcbiAqICAgcGFzc2NvZGUuXG4gKiBAcGFyYW0ge0ludGVnZXJ9IFtvcHRpb25zLndpbmRvdz0wXSBUaGUgYWxsb3dhYmxlIG1hcmdpbiBmb3IgdGhlIGNvdW50ZXIuXG4gKiAgIFRoZSBmdW5jdGlvbiB3aWxsIGNoZWNrIFwiV1wiIGNvZGVzIGluIHRoZSBmdXR1cmUgYWdhaW5zdCB0aGUgcHJvdmlkZWRcbiAqICAgcGFzc2NvZGUsIGUuZy4gaWYgVyA9IDEwLCBhbmQgQyA9IDUsIHRoaXMgZnVuY3Rpb24gd2lsbCBjaGVjayB0aGVcbiAqICAgcGFzc2NvZGUgYWdhaW5zdCBhbGwgT25lIFRpbWUgUGFzc2NvZGVzIGJldHdlZW4gNSBhbmQgMTUsIGluY2x1c2l2ZS5cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5lbmNvZGluZz1cImFzY2lpXCJdIEtleSBlbmNvZGluZyAoYXNjaWksIGhleCxcbiAqICAgYmFzZTMyLCBiYXNlNjQpLlxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFsZ29yaXRobT1cInNoYTFcIl0gSGFzaCBhbGdvcml0aG0gKHNoYTEsIHNoYTI1NixcbiAqICAgc2hhNTEyKS5cbiAqIEByZXR1cm4ge0Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiB0aGUgdG9rZW4gbWF0Y2hlcyB3aXRoaW4gdGhlIGdpdmVuXG4gKiAgIHdpbmRvdywgZmFsc2Ugb3RoZXJ3aXNlLlxuICogQG1ldGhvZCBob3Rw4oCkdmVyaWZ5XG4gKiBAZ2xvYmFsXG4gKi9cbmV4cG9ydHMuaG90cC52ZXJpZnkgPSBmdW5jdGlvbiBob3RwVmVyaWZ5IChvcHRpb25zKSB7XG4gIHJldHVybiBleHBvcnRzLmhvdHAudmVyaWZ5RGVsdGEob3B0aW9ucykgIT0gbnVsbDtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlIGNvdW50ZXIgdmFsdWUgYmFzZWQgb24gZ2l2ZW4gb3B0aW9ucy4gQSBjb3VudGVyIHZhbHVlIGNvbnZlcnRzIGFcbiAqIFRPVFAgdGltZSBpbnRvIGEgY291bnRlciB2YWx1ZSBieSBmaW5kaW5nIHRoZSBudW1iZXIgb2YgdGltZSBzdGVwcyB0aGF0IGhhdmVcbiAqIHBhc3NlZCBzaW5jZSB0aGUgZXBvY2ggdG8gdGhlIGN1cnJlbnQgdGltZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtJbnRlZ2VyfSBbb3B0aW9ucy50aW1lXSBUaW1lIGluIHNlY29uZHMgd2l0aCB3aGljaCB0byBjYWxjdWxhdGVcbiAqICAgY291bnRlciB2YWx1ZS4gRGVmYXVsdHMgdG8gYERhdGUubm93KClgLlxuICogQHBhcmFtIHtJbnRlZ2VyfSBbb3B0aW9ucy5zdGVwPTMwXSBUaW1lIHN0ZXAgaW4gc2Vjb25kc1xuICogQHBhcmFtIHtJbnRlZ2VyfSBbb3B0aW9ucy5lcG9jaD0wXSBJbml0aWFsIHRpbWUgc2luY2UgdGhlIFVOSVggZXBvY2ggZnJvbVxuICogICB3aGljaCB0byBjYWxjdWxhdGUgdGhlIGNvdW50ZXIgdmFsdWUuIERlZmF1bHRzIHRvIDAgKG5vIG9mZnNldCkuXG4gKiBAcGFyYW0ge0ludGVnZXJ9IFtvcHRpb25zLmluaXRpYWxfdGltZT0wXSAoREVQUkVDQVRFRC4gVXNlIGBlcG9jaGAgaW5zdGVhZC4pXG4gKiAgIEluaXRpYWwgdGltZSBpbiBzZWNvbmRzIHNpbmNlIHRoZSBVTklYIGVwb2NoIGZyb20gd2hpY2ggdG8gY2FsY3VsYXRlIHRoZVxuICogICBjb3VudGVyIHZhbHVlLiBEZWZhdWx0cyB0byAwIChubyBvZmZzZXQpLlxuICogQHJldHVybiB7SW50ZWdlcn0gVGhlIGNhbGN1bGF0ZWQgY291bnRlciB2YWx1ZS5cbiAqIEBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5fY291bnRlciA9IGZ1bmN0aW9uIF9jb3VudGVyIChvcHRpb25zKSB7XG4gIHZhciBzdGVwID0gb3B0aW9ucy5zdGVwIHx8IDMwO1xuICB2YXIgdGltZSA9IG9wdGlvbnMudGltZSAhPSBudWxsID8gKG9wdGlvbnMudGltZSAqIDEwMDApIDogRGF0ZS5ub3coKTtcblxuICAvLyBhbHNvIGFjY2VwdHMgJ2luaXRpYWxfdGltZScsIGJ1dCBkZXByZWNhdGVkXG4gIHZhciBlcG9jaCA9IChvcHRpb25zLmVwb2NoICE9IG51bGwgPyAob3B0aW9ucy5lcG9jaCAqIDEwMDApIDogKG9wdGlvbnMuaW5pdGlhbF90aW1lICogMTAwMCkpIHx8IDA7XG4gIGlmIChvcHRpb25zLmluaXRpYWxfdGltZSAhPSBudWxsKSBjb25zb2xlLndhcm4oJ1NwZWFrZWFzeSAtIERlcHJlY2F0aW9uIE5vdGljZSAtIFNwZWNpZnlpbmcgdGhlIGVwb2NoIHVzaW5nIGBpbml0aWFsX3RpbWVgIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQuIFVzZSBgZXBvY2hgIGluc3RlYWQuJyk7XG5cbiAgcmV0dXJuIE1hdGguZmxvb3IoKHRpbWUgLSBlcG9jaCkgLyBzdGVwIC8gMTAwMCk7XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlIGEgdGltZS1iYXNlZCBvbmUtdGltZSB0b2tlbi4gU3BlY2lmeSB0aGUga2V5LCBhbmQgcmVjZWl2ZSB0aGVcbiAqIG9uZS10aW1lIHBhc3N3b3JkIGZvciB0aGF0IHRpbWUgYXMgYSBzdHJpbmcuIEJ5IGRlZmF1bHQsIGl0IHVzZXMgdGhlIGN1cnJlbnRcbiAqIHRpbWUgYW5kIGEgdGltZSBzdGVwIG9mIDMwIHNlY29uZHMsIHNvIHRoZXJlIGlzIGEgbmV3IHRva2VuIGV2ZXJ5IDMwIHNlY29uZHMuXG4gKiBZb3UgbWF5IG92ZXJyaWRlIHRoZSB0aW1lIHN0ZXAgYW5kIGVwb2NoIGZvciBjdXN0b20gdGltaW5nLiBZb3UgY2FuIGFsc29cbiAqIHNwZWNpZnkgYSB0b2tlbiBsZW5ndGgsIGFzIHdlbGwgYXMgdGhlIGVuY29kaW5nIChBU0NJSSwgaGV4YWRlY2ltYWwsIG9yXG4gKiBiYXNlMzIpIGFuZCB0aGUgaGFzaGluZyBhbGdvcml0aG0gdG8gdXNlIChTSEExLCBTSEEyNTYsIFNIQTUxMikuXG4gKlxuICogVW5kZXIgdGhlIGhvb2QsIFRPVFAgY2FsY3VsYXRlcyB0aGUgY291bnRlciB2YWx1ZSBieSBmaW5kaW5nIGhvdyBtYW55IHRpbWVcbiAqIHN0ZXBzIGhhdmUgcGFzc2VkIHNpbmNlIHRoZSBlcG9jaCwgYW5kIGNhbGxzIEhPVFAgd2l0aCB0aGF0IGNvdW50ZXIgdmFsdWUuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLnNlY3JldCBTaGFyZWQgc2VjcmV0IGtleVxuICogQHBhcmFtIHtJbnRlZ2VyfSBbb3B0aW9ucy50aW1lXSBUaW1lIGluIHNlY29uZHMgd2l0aCB3aGljaCB0byBjYWxjdWxhdGVcbiAqICAgY291bnRlciB2YWx1ZS4gRGVmYXVsdHMgdG8gYERhdGUubm93KClgLlxuICogQHBhcmFtIHtJbnRlZ2VyfSBbb3B0aW9ucy5zdGVwPTMwXSBUaW1lIHN0ZXAgaW4gc2Vjb25kc1xuICogQHBhcmFtIHtJbnRlZ2VyfSBbb3B0aW9ucy5lcG9jaD0wXSBJbml0aWFsIHRpbWUgaW4gc2Vjb25kcyBzaW5jZSB0aGUgVU5JWFxuICogICBlcG9jaCBmcm9tIHdoaWNoIHRvIGNhbGN1bGF0ZSB0aGUgY291bnRlciB2YWx1ZS4gRGVmYXVsdHMgdG8gMCAobm8gb2Zmc2V0KS5cbiAqIEBwYXJhbSB7SW50ZWdlcn0gW29wdGlvbnMuY291bnRlcl0gQ291bnRlciB2YWx1ZSwgY2FsY3VsYXRlZCBieSBkZWZhdWx0LlxuICogQHBhcmFtIHtJbnRlZ2VyfSBbb3B0aW9ucy5kaWdpdHM9Nl0gVGhlIG51bWJlciBvZiBkaWdpdHMgZm9yIHRoZSBvbmUtdGltZVxuICogICBwYXNzY29kZS5cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5lbmNvZGluZz1cImFzY2lpXCJdIEtleSBlbmNvZGluZyAoYXNjaWksIGhleCxcbiAqICAgYmFzZTMyLCBiYXNlNjQpLlxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFsZ29yaXRobT1cInNoYTFcIl0gSGFzaCBhbGdvcml0aG0gKHNoYTEsIHNoYTI1NixcbiAqICAgc2hhNTEyKS5cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5rZXldIChERVBSRUNBVEVELiBVc2UgYHNlY3JldGAgaW5zdGVhZC4pXG4gKiAgIFNoYXJlZCBzZWNyZXQga2V5XG4gKiBAcGFyYW0ge0ludGVnZXJ9IFtvcHRpb25zLmluaXRpYWxfdGltZT0wXSAoREVQUkVDQVRFRC4gVXNlIGBlcG9jaGAgaW5zdGVhZC4pXG4gKiAgIEluaXRpYWwgdGltZSBpbiBzZWNvbmRzIHNpbmNlIHRoZSBVTklYIGVwb2NoIGZyb20gd2hpY2ggdG8gY2FsY3VsYXRlIHRoZVxuICogICBjb3VudGVyIHZhbHVlLiBEZWZhdWx0cyB0byAwIChubyBvZmZzZXQpLlxuICogQHBhcmFtIHtJbnRlZ2VyfSBbb3B0aW9ucy5sZW5ndGg9Nl0gKERFUFJFQ0FURUQuIFVzZSBgZGlnaXRzYCBpbnN0ZWFkLikgVGhlXG4gKiAgIG51bWJlciBvZiBkaWdpdHMgZm9yIHRoZSBvbmUtdGltZSBwYXNzY29kZS5cbiAqIEByZXR1cm4ge1N0cmluZ30gVGhlIG9uZS10aW1lIHBhc3Njb2RlLlxuICovXG5cbmV4cG9ydHMudG90cCA9IGZ1bmN0aW9uIHRvdHBHZW5lcmF0ZSAob3B0aW9ucykge1xuICAvLyBzaGFkb3cgb3B0aW9uc1xuICBvcHRpb25zID0gT2JqZWN0LmNyZWF0ZShvcHRpb25zKTtcblxuICAvLyBjYWxjdWxhdGUgZGVmYXVsdCBjb3VudGVyIHZhbHVlXG4gIGlmIChvcHRpb25zLmNvdW50ZXIgPT0gbnVsbCkgb3B0aW9ucy5jb3VudGVyID0gZXhwb3J0cy5fY291bnRlcihvcHRpb25zKTtcblxuICAvLyBwYXNzIHRvIGhvdHBcbiAgcmV0dXJuIHRoaXMuaG90cChvcHRpb25zKTtcbn07XG5cbi8vIEFsaWFzIHRpbWUoKSBmb3IgdG90cCgpXG5leHBvcnRzLnRpbWUgPSBleHBvcnRzLnRvdHA7XG5cbi8qKlxuICogVmVyaWZ5IGEgdGltZS1iYXNlZCBvbmUtdGltZSB0b2tlbiBhZ2FpbnN0IHRoZSBzZWNyZXQgYW5kIHJldHVybiB0aGUgZGVsdGEuXG4gKiBCeSBkZWZhdWx0LCBpdCB2ZXJpZmllcyB0aGUgdG9rZW4gYXQgdGhlIGN1cnJlbnQgdGltZSB3aW5kb3csIHdpdGggbm8gbGVld2F5XG4gKiAobm8gbG9vay1haGVhZCBvciBsb29rLWJlaGluZCkuIEEgdG9rZW4gdmFsaWRhdGVkIGF0IHRoZSBjdXJyZW50IHRpbWUgd2luZG93XG4gKiB3aWxsIGhhdmUgYSBkZWx0YSBvZiAwLlxuICpcbiAqIFlvdSBjYW4gc3BlY2lmeSBhIHdpbmRvdyB0byBhZGQgbW9yZSBsZWV3YXkgdG8gdGhlIHZlcmlmaWNhdGlvbiBwcm9jZXNzLlxuICogU2V0dGluZyB0aGUgd2luZG93IHBhcmFtIHdpbGwgY2hlY2sgZm9yIHRoZSB0b2tlbiBhdCB0aGUgZ2l2ZW4gY291bnRlciB2YWx1ZVxuICogYXMgd2VsbCBhcyBgd2luZG93YCB0b2tlbnMgYWhlYWQgYW5kIGB3aW5kb3dgIHRva2VucyBiZWhpbmQgKHR3by1zaWRlZFxuICogd2luZG93KS4gU2VlIHBhcmFtIGZvciBtb3JlIGluZm8uXG4gKlxuICogYHZlcmlmeURlbHRhKClgIHdpbGwgcmV0dXJuIHRoZSBkZWx0YSBiZXR3ZWVuIHRoZSBjb3VudGVyIHZhbHVlIG9mIHRoZSB0b2tlblxuICogYW5kIHRoZSBnaXZlbiBjb3VudGVyIHZhbHVlLiBGb3IgZXhhbXBsZSwgaWYgZ2l2ZW4gYSB0aW1lIGF0IGNvdW50ZXIgMTAwMCBhbmRcbiAqIGEgd2luZG93IG9mIDUsIGB2ZXJpZnlEZWx0YSgpYCB3aWxsIGxvb2sgYXQgdG9rZW5zIGZyb20gOTk1IHRvIDEwMDUsXG4gKiBpbmNsdXNpdmUuIEluIG90aGVyIHdvcmRzLCBpZiB0aGUgdGltZS1zdGVwIGlzIDMwIHNlY29uZHMsIGl0IHdpbGwgbG9vayBhdFxuICogdG9rZW5zIGZyb20gMi41IG1pbnV0ZXMgYWdvIHRvIDIuNSBtaW51dGVzIGluIHRoZSBmdXR1cmUsIGluY2x1c2l2ZS5cbiAqIElmIGl0IGZpbmRzIGl0IGF0IGNvdW50ZXIgcG9zaXRpb24gMTAwMiwgaXQgd2lsbCByZXR1cm4gYHsgZGVsdGE6IDIgfWAuXG4gKiBJZiBpdCBmaW5kcyBpdCBhdCBjb3VudGVyIHBvc2l0aW9uIDk5NywgaXQgd2lsbCByZXR1cm4gYHsgZGVsdGE6IC0zIH1gLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy5zZWNyZXQgU2hhcmVkIHNlY3JldCBrZXlcbiAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLnRva2VuIFBhc3Njb2RlIHRvIHZhbGlkYXRlXG4gKiBAcGFyYW0ge0ludGVnZXJ9IFtvcHRpb25zLnRpbWVdIFRpbWUgaW4gc2Vjb25kcyB3aXRoIHdoaWNoIHRvIGNhbGN1bGF0ZVxuICogICBjb3VudGVyIHZhbHVlLiBEZWZhdWx0cyB0byBgRGF0ZS5ub3coKWAuXG4gKiBAcGFyYW0ge0ludGVnZXJ9IFtvcHRpb25zLnN0ZXA9MzBdIFRpbWUgc3RlcCBpbiBzZWNvbmRzXG4gKiBAcGFyYW0ge0ludGVnZXJ9IFtvcHRpb25zLmVwb2NoPTBdIEluaXRpYWwgdGltZSBpbiBzZWNvbmRzIHNpbmNlIHRoZSBVTklYXG4gKiAgIGVwb2NoIGZyb20gd2hpY2ggdG8gY2FsY3VsYXRlIHRoZSBjb3VudGVyIHZhbHVlLiBEZWZhdWx0cyB0byAwIChubyBvZmZzZXQpLlxuICogQHBhcmFtIHtJbnRlZ2VyfSBbb3B0aW9ucy5jb3VudGVyXSBDb3VudGVyIHZhbHVlLCBjYWxjdWxhdGVkIGJ5IGRlZmF1bHQuXG4gKiBAcGFyYW0ge0ludGVnZXJ9IFtvcHRpb25zLmRpZ2l0cz02XSBUaGUgbnVtYmVyIG9mIGRpZ2l0cyBmb3IgdGhlIG9uZS10aW1lXG4gKiAgIHBhc3Njb2RlLlxuICogQHBhcmFtIHtJbnRlZ2VyfSBbb3B0aW9ucy53aW5kb3c9MF0gVGhlIGFsbG93YWJsZSBtYXJnaW4gZm9yIHRoZSBjb3VudGVyLlxuICogICBUaGUgZnVuY3Rpb24gd2lsbCBjaGVjayBcIldcIiBjb2RlcyBpbiB0aGUgZnV0dXJlIGFuZCB0aGUgcGFzdCBhZ2FpbnN0IHRoZVxuICogICBwcm92aWRlZCBwYXNzY29kZSwgZS5nLiBpZiBXID0gNSwgYW5kIEMgPSAxMDAwLCB0aGlzIGZ1bmN0aW9uIHdpbGwgY2hlY2tcbiAqICAgdGhlIHBhc3Njb2RlIGFnYWluc3QgYWxsIE9uZSBUaW1lIFBhc3Njb2RlcyBiZXR3ZWVuIDk5NSBhbmQgMTAwNSxcbiAqICAgaW5jbHVzaXZlLlxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmVuY29kaW5nPVwiYXNjaWlcIl0gS2V5IGVuY29kaW5nIChhc2NpaSwgaGV4LFxuICogICBiYXNlMzIsIGJhc2U2NCkuXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYWxnb3JpdGhtPVwic2hhMVwiXSBIYXNoIGFsZ29yaXRobSAoc2hhMSwgc2hhMjU2LFxuICogICBzaGE1MTIpLlxuICogQHJldHVybiB7T2JqZWN0fSBPbiBzdWNjZXNzLCByZXR1cm5zIGFuIG9iamVjdCB3aXRoIHRoZSB0aW1lIHN0ZXBcbiAqICAgZGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSBjbGllbnQgYW5kIHRoZSBzZXJ2ZXIgYXMgdGhlIGBkZWx0YWAgcHJvcGVydHkgKGUuZy5cbiAqICAgYHsgZGVsdGE6IDAgfWApLlxuICogQG1ldGhvZCB0b3Rw4oCkdmVyaWZ5RGVsdGFcbiAqIEBnbG9iYWxcbiAqL1xuXG5leHBvcnRzLnRvdHAudmVyaWZ5RGVsdGEgPSBmdW5jdGlvbiB0b3RwVmVyaWZ5RGVsdGEgKG9wdGlvbnMpIHtcbiAgLy8gc2hhZG93IG9wdGlvbnNcbiAgb3B0aW9ucyA9IE9iamVjdC5jcmVhdGUob3B0aW9ucyk7XG5cbiAgLy8gdW5wYWNrIG9wdGlvbnNcbiAgdmFyIHdpbmRvdyA9IHBhcnNlSW50KG9wdGlvbnMud2luZG93LCAxMCkgfHwgMDtcblxuICAvLyBjYWxjdWxhdGUgZGVmYXVsdCBjb3VudGVyIHZhbHVlXG4gIGlmIChvcHRpb25zLmNvdW50ZXIgPT0gbnVsbCkgb3B0aW9ucy5jb3VudGVyID0gZXhwb3J0cy5fY291bnRlcihvcHRpb25zKTtcblxuICAvLyBhZGp1c3QgZm9yIHR3by1zaWRlZCB3aW5kb3dcbiAgb3B0aW9ucy5jb3VudGVyIC09IHdpbmRvdztcbiAgb3B0aW9ucy53aW5kb3cgKz0gd2luZG93O1xuXG4gIC8vIHBhc3MgdG8gaG90cC52ZXJpZnlEZWx0YVxuICB2YXIgZGVsdGEgPSBleHBvcnRzLmhvdHAudmVyaWZ5RGVsdGEob3B0aW9ucyk7XG5cbiAgLy8gYWRqdXN0IGZvciB0d28tc2lkZWQgd2luZG93XG4gIGlmIChkZWx0YSkge1xuICAgIGRlbHRhLmRlbHRhIC09IHdpbmRvdztcbiAgfVxuXG4gIHJldHVybiBkZWx0YTtcbn07XG5cbi8qKlxuICogVmVyaWZ5IGEgdGltZS1iYXNlZCBvbmUtdGltZSB0b2tlbiBhZ2FpbnN0IHRoZSBzZWNyZXQgYW5kIHJldHVybiB0cnVlIGlmIGl0XG4gKiB2ZXJpZmllcy4gSGVscGVyIGZ1bmN0aW9uIGZvciB2ZXJpZnlEZWx0YSgpIHRoYXQgcmV0dXJucyBhIGJvb2xlYW4gaW5zdGVhZCBvZlxuICogYW4gb2JqZWN0LiBGb3IgbW9yZSBvbiBob3cgdG8gdXNlIGEgd2luZG93IHdpdGggdGhpcywgc2VlXG4gKiB7QGxpbmsgdG90cC52ZXJpZnlEZWx0YX0uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLnNlY3JldCBTaGFyZWQgc2VjcmV0IGtleVxuICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMudG9rZW4gUGFzc2NvZGUgdG8gdmFsaWRhdGVcbiAqIEBwYXJhbSB7SW50ZWdlcn0gW29wdGlvbnMudGltZV0gVGltZSBpbiBzZWNvbmRzIHdpdGggd2hpY2ggdG8gY2FsY3VsYXRlXG4gKiAgIGNvdW50ZXIgdmFsdWUuIERlZmF1bHRzIHRvIGBEYXRlLm5vdygpYC5cbiAqIEBwYXJhbSB7SW50ZWdlcn0gW29wdGlvbnMuc3RlcD0zMF0gVGltZSBzdGVwIGluIHNlY29uZHNcbiAqIEBwYXJhbSB7SW50ZWdlcn0gW29wdGlvbnMuZXBvY2g9MF0gSW5pdGlhbCB0aW1lIGluIHNlY29uZHMgIHNpbmNlIHRoZSBVTklYXG4gKiAgIGVwb2NoIGZyb20gd2hpY2ggdG8gY2FsY3VsYXRlIHRoZSBjb3VudGVyIHZhbHVlLiBEZWZhdWx0cyB0byAwIChubyBvZmZzZXQpLlxuICogQHBhcmFtIHtJbnRlZ2VyfSBbb3B0aW9ucy5jb3VudGVyXSBDb3VudGVyIHZhbHVlLCBjYWxjdWxhdGVkIGJ5IGRlZmF1bHQuXG4gKiBAcGFyYW0ge0ludGVnZXJ9IFtvcHRpb25zLmRpZ2l0cz02XSBUaGUgbnVtYmVyIG9mIGRpZ2l0cyBmb3IgdGhlIG9uZS10aW1lXG4gKiAgIHBhc3Njb2RlLlxuICogQHBhcmFtIHtJbnRlZ2VyfSBbb3B0aW9ucy53aW5kb3c9MF0gVGhlIGFsbG93YWJsZSBtYXJnaW4gZm9yIHRoZSBjb3VudGVyLlxuICogICBUaGUgZnVuY3Rpb24gd2lsbCBjaGVjayBcIldcIiBjb2RlcyBpbiB0aGUgZnV0dXJlIGFuZCB0aGUgcGFzdCBhZ2FpbnN0IHRoZVxuICogICBwcm92aWRlZCBwYXNzY29kZSwgZS5nLiBpZiBXID0gNSwgYW5kIEMgPSAxMDAwLCB0aGlzIGZ1bmN0aW9uIHdpbGwgY2hlY2tcbiAqICAgdGhlIHBhc3Njb2RlIGFnYWluc3QgYWxsIE9uZSBUaW1lIFBhc3Njb2RlcyBiZXR3ZWVuIDk5NSBhbmQgMTAwNSxcbiAqICAgaW5jbHVzaXZlLlxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmVuY29kaW5nPVwiYXNjaWlcIl0gS2V5IGVuY29kaW5nIChhc2NpaSwgaGV4LFxuICogICBiYXNlMzIsIGJhc2U2NCkuXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYWxnb3JpdGhtPVwic2hhMVwiXSBIYXNoIGFsZ29yaXRobSAoc2hhMSwgc2hhMjU2LFxuICogICBzaGE1MTIpLlxuICogQHJldHVybiB7Qm9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIHRoZSB0b2tlbiBtYXRjaGVzIHdpdGhpbiB0aGUgZ2l2ZW5cbiAqICAgd2luZG93LCBmYWxzZSBvdGhlcndpc2UuXG4gKiBAbWV0aG9kIHRvdHDigKR2ZXJpZnlcbiAqIEBnbG9iYWxcbiAqL1xuZXhwb3J0cy50b3RwLnZlcmlmeSA9IGZ1bmN0aW9uIHRvdHBWZXJpZnkgKG9wdGlvbnMpIHtcbiAgcmV0dXJuIGV4cG9ydHMudG90cC52ZXJpZnlEZWx0YShvcHRpb25zKSAhPSBudWxsO1xufTtcblxuLyoqXG4gKiBAdHlwZWRlZiBHZW5lcmF0ZWRTZWNyZXRcbiAqIEB0eXBlIE9iamVjdFxuICogQHByb3BlcnR5IHtTdHJpbmd9IGFzY2lpIEFTQ0lJIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBzZWNyZXRcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBoZXggSGV4IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBzZWNyZXRcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBiYXNlMzIgQmFzZTMyIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBzZWNyZXRcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBxcl9jb2RlX2FzY2lpIFVSTCBmb3IgdGhlIFFSIGNvZGUgZm9yIHRoZSBBU0NJSSBzZWNyZXQuXG4gKiBAcHJvcGVydHkge1N0cmluZ30gcXJfY29kZV9oZXggVVJMIGZvciB0aGUgUVIgY29kZSBmb3IgdGhlIGhleCBzZWNyZXQuXG4gKiBAcHJvcGVydHkge1N0cmluZ30gcXJfY29kZV9iYXNlMzIgVVJMIGZvciB0aGUgUVIgY29kZSBmb3IgdGhlIGJhc2UzMiBzZWNyZXQuXG4gKiBAcHJvcGVydHkge1N0cmluZ30gZ29vZ2xlX2F1dGhfcXIgVVJMIGZvciB0aGUgR29vZ2xlIEF1dGhlbnRpY2F0b3Igb3RwYXV0aFxuICogICBVUkwncyBRUiBjb2RlLlxuICogQHByb3BlcnR5IHtTdHJpbmd9IG90cGF1dGhfdXJsIEdvb2dsZSBBdXRoZW50aWNhdG9yLWNvbXBhdGlibGUgb3RwYXV0aCBVUkwuXG4gKi9cblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSByYW5kb20gc2VjcmV0IHdpdGggdGhlIHNldCBBLVogYS16IDAtOSBhbmQgc3ltYm9scywgb2YgYW55IGxlbmd0aFxuICogKGRlZmF1bHQgMzIpLiBSZXR1cm5zIHRoZSBzZWNyZXQga2V5IGluIEFTQ0lJLCBoZXhhZGVjaW1hbCwgYW5kIGJhc2UzMiBmb3JtYXQsXG4gKiBhbG9uZyB3aXRoIHRoZSBVUkwgdXNlZCBmb3IgdGhlIFFSIGNvZGUgZm9yIEdvb2dsZSBBdXRoZW50aWNhdG9yIChhbiBvdHBhdXRoXG4gKiBVUkwpLiBVc2UgYSBRUiBjb2RlIGxpYnJhcnkgdG8gZ2VuZXJhdGUgYSBRUiBjb2RlIGJhc2VkIG9uIHRoZSBHb29nbGVcbiAqIEF1dGhlbnRpY2F0b3IgVVJMIHRvIG9idGFpbiBhIFFSIGNvZGUgeW91IGNhbiBzY2FuIGludG8gdGhlIGFwcC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtJbnRlZ2VyfSBbb3B0aW9ucy5sZW5ndGg9MzJdIExlbmd0aCBvZiB0aGUgc2VjcmV0XG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnN5bWJvbHM9ZmFsc2VdIFdoZXRoZXIgdG8gaW5jbHVkZSBzeW1ib2xzXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLm90cGF1dGhfdXJsPXRydWVdIFdoZXRoZXIgdG8gb3V0cHV0IGEgR29vZ2xlXG4gKiAgIEF1dGhlbnRpY2F0b3ItY29tcGF0aWJsZSBvdHBhdXRoOi8vIFVSTCAob25seSByZXR1cm5zIG90cGF1dGg6Ly8gVVJMLCBub1xuICogICBRUiBjb2RlKVxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLm5hbWVdIFRoZSBuYW1lIHRvIHVzZSB3aXRoIEdvb2dsZSBBdXRoZW50aWNhdG9yLlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5xcl9jb2Rlcz1mYWxzZV0gKERFUFJFQ0FURUQuIERvIG5vdCB1c2UgdG8gcHJldmVudFxuICogICBsZWFraW5nIG9mIHNlY3JldCB0byBhIHRoaXJkIHBhcnR5LiBVc2UgeW91ciBvd24gUVIgY29kZSBpbXBsZW1lbnRhdGlvbi4pXG4gKiAgIE91dHB1dCBRUiBjb2RlIFVSTHMgZm9yIHRoZSB0b2tlbi5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuZ29vZ2xlX2F1dGhfcXI9ZmFsc2VdIChERVBSRUNBVEVELiBEbyBub3QgdXNlIHRvXG4gKiAgIHByZXZlbnQgbGVha2luZyBvZiBzZWNyZXQgdG8gYSB0aGlyZCBwYXJ0eS4gVXNlIHlvdXIgb3duIFFSIGNvZGVcbiAqICAgaW1wbGVtZW50YXRpb24uKSBPdXRwdXQgYSBHb29nbGUgQXV0aGVudGljYXRvciBvdHBhdXRoOi8vIFFSIGNvZGUgVVJMLlxuICogQHJldHVybiB7T2JqZWN0fVxuICogQHJldHVybiB7R2VuZXJhdGVkU2VjcmV0fSBUaGUgZ2VuZXJhdGVkIHNlY3JldCBrZXkuXG4gKi9cbmV4cG9ydHMuZ2VuZXJhdGVTZWNyZXQgPSBmdW5jdGlvbiBnZW5lcmF0ZVNlY3JldCAob3B0aW9ucykge1xuICAvLyBvcHRpb25zXG4gIGlmICghb3B0aW9ucykgb3B0aW9ucyA9IHt9O1xuICB2YXIgbGVuZ3RoID0gb3B0aW9ucy5sZW5ndGggfHwgMzI7XG4gIHZhciBuYW1lID0gZW5jb2RlVVJJQ29tcG9uZW50KG9wdGlvbnMubmFtZSB8fCAnU2VjcmV0S2V5Jyk7XG4gIHZhciBxcl9jb2RlcyA9IG9wdGlvbnMucXJfY29kZXMgfHwgZmFsc2U7XG4gIHZhciBnb29nbGVfYXV0aF9xciA9IG9wdGlvbnMuZ29vZ2xlX2F1dGhfcXIgfHwgZmFsc2U7XG4gIHZhciBvdHBhdXRoX3VybCA9IG9wdGlvbnMub3RwYXV0aF91cmwgIT0gbnVsbCA/IG9wdGlvbnMub3RwYXV0aF91cmwgOiB0cnVlO1xuICB2YXIgc3ltYm9scyA9IHRydWU7XG5cbiAgLy8gdHVybiBvZmYgc3ltYm9scyBvbmx5IHdoZW4gZXhwbGljaXR5IHRvbGQgdG9cbiAgaWYgKG9wdGlvbnMuc3ltYm9scyAhPT0gdW5kZWZpbmVkICYmIG9wdGlvbnMuc3ltYm9scyA9PT0gZmFsc2UpIHtcbiAgICBzeW1ib2xzID0gZmFsc2U7XG4gIH1cblxuICAvLyBnZW5lcmF0ZSBhbiBhc2NpaSBrZXlcbiAgdmFyIGtleSA9IHRoaXMuZ2VuZXJhdGVTZWNyZXRBU0NJSShsZW5ndGgsIHN5bWJvbHMpO1xuXG4gIC8vIHJldHVybiBhIFNlY3JldEtleSB3aXRoIGFzY2lpLCBoZXgsIGFuZCBiYXNlMzJcbiAgdmFyIFNlY3JldEtleSA9IHt9O1xuICBTZWNyZXRLZXkuYXNjaWkgPSBrZXk7XG4gIFNlY3JldEtleS5oZXggPSBCdWZmZXIoa2V5LCAnYXNjaWknKS50b1N0cmluZygnaGV4Jyk7XG4gIFNlY3JldEtleS5iYXNlMzIgPSBiYXNlMzIuZW5jb2RlKEJ1ZmZlcihrZXkpKS50b1N0cmluZygpLnJlcGxhY2UoLz0vZywgJycpO1xuXG4gIC8vIGdlbmVyYXRlIHNvbWUgcXIgY29kZXMgaWYgcmVxdWVzdGVkXG4gIGlmIChxcl9jb2Rlcykge1xuICAgIGNvbnNvbGUud2FybignU3BlYWtlYXN5IC0gRGVwcmVjYXRpb24gTm90aWNlIC0gZ2VuZXJhdGVTZWNyZXQoKSBRUiBjb2RlcyBhcmUgZGVwcmVjYXRlZCBhbmQgbm8gbG9uZ2VyIHN1cHBvcnRlZC4gUGxlYXNlIHVzZSB5b3VyIG93biBRUiBjb2RlIGltcGxlbWVudGF0aW9uLicpO1xuICAgIFNlY3JldEtleS5xcl9jb2RlX2FzY2lpID0gJ2h0dHBzOi8vY2hhcnQuZ29vZ2xlYXBpcy5jb20vY2hhcnQ/Y2hzPTE2NngxNjYmY2hsZD1MfDAmY2h0PXFyJmNobD0nICsgZW5jb2RlVVJJQ29tcG9uZW50KFNlY3JldEtleS5hc2NpaSk7XG4gICAgU2VjcmV0S2V5LnFyX2NvZGVfaGV4ID0gJ2h0dHBzOi8vY2hhcnQuZ29vZ2xlYXBpcy5jb20vY2hhcnQ/Y2hzPTE2NngxNjYmY2hsZD1MfDAmY2h0PXFyJmNobD0nICsgZW5jb2RlVVJJQ29tcG9uZW50KFNlY3JldEtleS5oZXgpO1xuICAgIFNlY3JldEtleS5xcl9jb2RlX2Jhc2UzMiA9ICdodHRwczovL2NoYXJ0Lmdvb2dsZWFwaXMuY29tL2NoYXJ0P2Nocz0xNjZ4MTY2JmNobGQ9THwwJmNodD1xciZjaGw9JyArIGVuY29kZVVSSUNvbXBvbmVudChTZWNyZXRLZXkuYmFzZTMyKTtcbiAgfVxuXG4gIC8vIGFkZCBpbiB0aGUgR29vZ2xlIEF1dGhlbnRpY2F0b3ItY29tcGF0aWJsZSBvdHBhdXRoIFVSTFxuICBpZiAob3RwYXV0aF91cmwpIHtcbiAgICBTZWNyZXRLZXkub3RwYXV0aF91cmwgPSBleHBvcnRzLm90cGF1dGhVUkwoe1xuICAgICAgc2VjcmV0OiBTZWNyZXRLZXkuYXNjaWksXG4gICAgICBsYWJlbDogbmFtZVxuICAgIH0pO1xuICB9XG5cbiAgLy8gZ2VuZXJhdGUgYSBRUiBjb2RlIGZvciB1c2UgaW4gR29vZ2xlIEF1dGhlbnRpY2F0b3IgaWYgcmVxdWVzdGVkXG4gIGlmIChnb29nbGVfYXV0aF9xcikge1xuICAgIGNvbnNvbGUud2FybignU3BlYWtlYXN5IC0gRGVwcmVjYXRpb24gTm90aWNlIC0gZ2VuZXJhdGVTZWNyZXQoKSBHb29nbGUgQXV0aCBRUiBjb2RlIGlzIGRlcHJlY2F0ZWQgYW5kIG5vIGxvbmdlciBzdXBwb3J0ZWQuIFBsZWFzZSB1c2UgeW91ciBvd24gUVIgY29kZSBpbXBsZW1lbnRhdGlvbi4nKTtcbiAgICBTZWNyZXRLZXkuZ29vZ2xlX2F1dGhfcXIgPSAnaHR0cHM6Ly9jaGFydC5nb29nbGVhcGlzLmNvbS9jaGFydD9jaHM9MTY2eDE2NiZjaGxkPUx8MCZjaHQ9cXImY2hsPScgKyBlbmNvZGVVUklDb21wb25lbnQoZXhwb3J0cy5vdHBhdXRoVVJMKHsgc2VjcmV0OiBTZWNyZXRLZXkuYmFzZTMyLCBsYWJlbDogbmFtZSB9KSk7XG4gIH1cblxuICByZXR1cm4gU2VjcmV0S2V5O1xufTtcblxuLy8gQmFja3dhcmRzIGNvbXBhdGliaWxpdHkgLSBnZW5lcmF0ZV9rZXkgaXMgZGVwcmVjYXRlZFxuZXhwb3J0cy5nZW5lcmF0ZV9rZXkgPSB1dGlsLmRlcHJlY2F0ZShmdW5jdGlvbiAob3B0aW9ucykge1xuICByZXR1cm4gZXhwb3J0cy5nZW5lcmF0ZVNlY3JldChvcHRpb25zKTtcbn0sICdTcGVha2Vhc3kgLSBEZXByZWNhdGlvbiBOb3RpY2UgLSBgZ2VuZXJhdGVfa2V5KClgIGlzIGRlcHJlY2lhdGVkLCBwbGVhc2UgdXNlIGBnZW5lcmF0ZVNlY3JldCgpYCBpbnN0ZWFkLicpO1xuXG4vKipcbiAqIEdlbmVyYXRlcyBhIGtleSBvZiBhIGNlcnRhaW4gbGVuZ3RoIChkZWZhdWx0IDMyKSBmcm9tIEEtWiwgYS16LCAwLTksIGFuZFxuICogc3ltYm9scyAoaWYgcmVxdWVzdGVkKS5cbiAqXG4gKiBAcGFyYW0gIHtJbnRlZ2VyfSBbbGVuZ3RoPTMyXSAgVGhlIGxlbmd0aCBvZiB0aGUga2V5LlxuICogQHBhcmFtICB7Qm9vbGVhbn0gW3N5bWJvbHM9ZmFsc2VdIFdoZXRoZXIgdG8gaW5jbHVkZSBzeW1ib2xzIGluIHRoZSBrZXkuXG4gKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSBnZW5lcmF0ZWQga2V5LlxuICovXG5leHBvcnRzLmdlbmVyYXRlU2VjcmV0QVNDSUkgPSBmdW5jdGlvbiBnZW5lcmF0ZVNlY3JldEFTQ0lJIChsZW5ndGgsIHN5bWJvbHMpIHtcbiAgdmFyIGJ5dGVzID0gY3J5cHRvLnJhbmRvbUJ5dGVzKGxlbmd0aCB8fCAzMik7XG4gIHZhciBzZXQgPSAnMDEyMzQ1Njc4OUFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFRaYWJjZGVmZ2hpa2xtbm9wcXJzdHV2d3h5eic7XG4gIGlmIChzeW1ib2xzKSB7XG4gICAgc2V0ICs9ICchQCMkJV4mKigpPD4/L1tde30sLjo7JztcbiAgfVxuXG4gIHZhciBvdXRwdXQgPSAnJztcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBieXRlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBvdXRwdXQgKz0gc2V0W01hdGguZmxvb3IoYnl0ZXNbaV0gLyAyNTUuMCAqIChzZXQubGVuZ3RoIC0gMSkpXTtcbiAgfVxuICByZXR1cm4gb3V0cHV0O1xufTtcblxuLy8gQmFja3dhcmRzIGNvbXBhdGliaWxpdHkgLSBnZW5lcmF0ZV9rZXlfYXNjaWkgaXMgZGVwcmVjYXRlZFxuZXhwb3J0cy5nZW5lcmF0ZV9rZXlfYXNjaWkgPSB1dGlsLmRlcHJlY2F0ZShmdW5jdGlvbiAobGVuZ3RoLCBzeW1ib2xzKSB7XG4gIHJldHVybiBleHBvcnRzLmdlbmVyYXRlU2VjcmV0QVNDSUkobGVuZ3RoLCBzeW1ib2xzKTtcbn0sICdTcGVha2Vhc3kgLSBEZXByZWNhdGlvbiBOb3RpY2UgLSBgZ2VuZXJhdGVfa2V5X2FzY2lpKClgIGlzIGRlcHJlY2lhdGVkLCBwbGVhc2UgdXNlIGBnZW5lcmF0ZVNlY3JldEFTQ0lJKClgIGluc3RlYWQuJyk7XG5cbi8qKlxuICogR2VuZXJhdGUgYSBHb29nbGUgQXV0aGVudGljYXRvci1jb21wYXRpYmxlIG90cGF1dGg6Ly8gVVJMIGZvciBwYXNzaW5nIHRoZVxuICogc2VjcmV0IHRvIGEgbW9iaWxlIGRldmljZSB0byBpbnN0YWxsIHRoZSBzZWNyZXQuXG4gKlxuICogQXV0aGVudGljYXRvciBjb25zaWRlcnMgVE9UUCBjb2RlcyB2YWxpZCBmb3IgMzAgc2Vjb25kcy4gQWRkaXRpb25hbGx5LFxuICogdGhlIGFwcCBwcmVzZW50cyA2IGRpZ2l0cyBjb2RlcyB0byB0aGUgdXNlci4gQWNjb3JkaW5nIHRvIHRoZVxuICogZG9jdW1lbnRhdGlvbiwgdGhlIHBlcmlvZCBhbmQgbnVtYmVyIG9mIGRpZ2l0cyBhcmUgY3VycmVudGx5IGlnbm9yZWQgYnlcbiAqIHRoZSBhcHAuXG4gKlxuICogVG8gZ2VuZXJhdGUgYSBzdWl0YWJsZSBRUiBDb2RlLCBwYXNzIHRoZSBnZW5lcmF0ZWQgVVJMIHRvIGEgUVIgQ29kZVxuICogZ2VuZXJhdG9yLCBzdWNoIGFzIHRoZSBgcXItaW1hZ2VgIG1vZHVsZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMuc2VjcmV0IFNoYXJlZCBzZWNyZXQga2V5XG4gKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy5sYWJlbCBVc2VkIHRvIGlkZW50aWZ5IHRoZSBhY2NvdW50IHdpdGggd2hpY2hcbiAqICAgdGhlIHNlY3JldCBrZXkgaXMgYXNzb2NpYXRlZCwgZS5nLiB0aGUgdXNlcidzIGVtYWlsIGFkZHJlc3MuXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMudHlwZT1cInRvdHBcIl0gRWl0aGVyIFwiaG90cFwiIG9yIFwidG90cFwiLlxuICogQHBhcmFtIHtJbnRlZ2VyfSBbb3B0aW9ucy5jb3VudGVyXSBUaGUgaW5pdGlhbCBjb3VudGVyIHZhbHVlLCByZXF1aXJlZFxuICogICBmb3IgSE9UUC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5pc3N1ZXJdIFRoZSBwcm92aWRlciBvciBzZXJ2aWNlIHdpdGggd2hpY2ggdGhlXG4gKiAgIHNlY3JldCBrZXkgaXMgYXNzb2NpYXRlZC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbGdvcml0aG09XCJzaGExXCJdIEhhc2ggYWxnb3JpdGhtIChzaGExLCBzaGEyNTYsXG4gKiAgIHNoYTUxMikuXG4gKiBAcGFyYW0ge0ludGVnZXJ9IFtvcHRpb25zLmRpZ2l0cz02XSBUaGUgbnVtYmVyIG9mIGRpZ2l0cyBmb3IgdGhlIG9uZS10aW1lXG4gKiAgIHBhc3Njb2RlLiBDdXJyZW50bHkgaWdub3JlZCBieSBHb29nbGUgQXV0aGVudGljYXRvci5cbiAqIEBwYXJhbSB7SW50ZWdlcn0gW29wdGlvbnMucGVyaW9kPTMwXSBUaGUgbGVuZ3RoIG9mIHRpbWUgZm9yIHdoaWNoIGEgVE9UUFxuICogICBjb2RlIHdpbGwgYmUgdmFsaWQsIGluIHNlY29uZHMuIEN1cnJlbnRseSBpZ25vcmVkIGJ5IEdvb2dsZVxuICogICBBdXRoZW50aWNhdG9yLlxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmVuY29kaW5nXSBLZXkgZW5jb2RpbmcgKGFzY2lpLCBoZXgsIGJhc2UzMixcbiAqICAgYmFzZTY0KS4gSWYgdGhlIGtleSBpcyBub3QgZW5jb2RlZCBpbiBCYXNlLTMyLCBpdCB3aWxsIGJlIHJlZW5jb2RlZC5cbiAqIEByZXR1cm4ge1N0cmluZ30gQSBVUkwgc3VpdGFibGUgZm9yIHVzZSB3aXRoIHRoZSBHb29nbGUgQXV0aGVudGljYXRvci5cbiAqIEB0aHJvd3MgRXJyb3IgaWYgc2VjcmV0IG9yIGxhYmVsIGlzIG1pc3NpbmcsIG9yIGlmIGhvdHAgaXMgdXNlZCBhbmQgYVxuICAgIGNvdW50ZXIgaXMgbWlzc2luZywgaWYgdGhlIHR5cGUgaXMgbm90IG9uZSBvZiBgaG90cGAgb3IgYHRvdHBgLCBpZiB0aGVcbiAgICBudW1iZXIgb2YgZGlnaXRzIGlzIG5vbi1udW1lcmljLCBvciBhbiBpbnZhbGlkIHBlcmlvZCBpcyB1c2VkLiBXYXJucyBpZlxuICAgIHRoZSBudW1iZXIgb2YgZGlnaXRzIGlzIG5vdCBlaXRoZXIgNiBvciA4ICh0aG91Z2ggNiBpcyB0aGUgb25seSBvbmVcbiAgICBzdXBwb3J0ZWQgYnkgR29vZ2xlIEF1dGhlbnRpY2F0b3IpLCBhbmQgaWYgdGhlIGhhc2hpaG5nIGFsZ29yaXRobSBpc1xuICAgIG5vdCBvbmUgb2YgdGhlIHN1cHBvcnRlZCBTSEExLCBTSEEyNTYsIG9yIFNIQTUxMi5cbiAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZS9nb29nbGUtYXV0aGVudGljYXRvci93aWtpL0tleS1VcmktRm9ybWF0XG4gKi9cblxuZXhwb3J0cy5vdHBhdXRoVVJMID0gZnVuY3Rpb24gb3RwYXV0aFVSTCAob3B0aW9ucykge1xuICAvLyB1bnBhY2sgb3B0aW9uc1xuICB2YXIgc2VjcmV0ID0gb3B0aW9ucy5zZWNyZXQ7XG4gIHZhciBsYWJlbCA9IG9wdGlvbnMubGFiZWw7XG4gIHZhciBpc3N1ZXIgPSBvcHRpb25zLmlzc3VlcjtcbiAgdmFyIHR5cGUgPSAob3B0aW9ucy50eXBlIHx8ICd0b3RwJykudG9Mb3dlckNhc2UoKTtcbiAgdmFyIGNvdW50ZXIgPSBvcHRpb25zLmNvdW50ZXI7XG4gIHZhciBhbGdvcml0aG0gPSBvcHRpb25zLmFsZ29yaXRobTtcbiAgdmFyIGRpZ2l0cyA9IG9wdGlvbnMuZGlnaXRzO1xuICB2YXIgcGVyaW9kID0gb3B0aW9ucy5wZXJpb2Q7XG4gIHZhciBlbmNvZGluZyA9IG9wdGlvbnMuZW5jb2RpbmcgfHwgJ2FzY2lpJztcblxuICAvLyB2YWxpZGF0ZSB0eXBlXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ3RvdHAnOlxuICAgIGNhc2UgJ2hvdHAnOlxuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignU3BlYWtlYXN5IC0gb3RwYXV0aFVSTCAtIEludmFsaWQgdHlwZSBgJyArIHR5cGUgKyAnYDsgbXVzdCBiZSBgaG90cGAgb3IgYHRvdHBgJyk7XG4gIH1cblxuICAvLyB2YWxpZGF0ZSByZXF1aXJlZCBvcHRpb25zXG4gIGlmICghc2VjcmV0KSB0aHJvdyBuZXcgRXJyb3IoJ1NwZWFrZWFzeSAtIG90cGF1dGhVUkwgLSBNaXNzaW5nIHNlY3JldCcpO1xuICBpZiAoIWxhYmVsKSB0aHJvdyBuZXcgRXJyb3IoJ1NwZWFrZWFzeSAtIG90cGF1dGhVUkwgLSBNaXNzaW5nIGxhYmVsJyk7XG5cbiAgLy8gcmVxdWlyZSBjb3VudGVyIGZvciBIT1RQXG4gIGlmICh0eXBlID09PSAnaG90cCcgJiYgKGNvdW50ZXIgPT09IG51bGwgfHwgdHlwZW9mIGNvdW50ZXIgPT09ICd1bmRlZmluZWQnKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignU3BlYWtlYXN5IC0gb3RwYXV0aFVSTCAtIE1pc3NpbmcgY291bnRlciB2YWx1ZSBmb3IgSE9UUCcpO1xuICB9XG5cbiAgLy8gY29udmVydCBzZWNyZXQgdG8gYmFzZTMyXG4gIGlmIChlbmNvZGluZyAhPT0gJ2Jhc2UzMicpIHNlY3JldCA9IG5ldyBCdWZmZXIoc2VjcmV0LCBlbmNvZGluZyk7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoc2VjcmV0KSkgc2VjcmV0ID0gYmFzZTMyLmVuY29kZShzZWNyZXQpO1xuXG4gIC8vIGJ1aWxkIHF1ZXJ5IHdoaWxlIHZhbGlkYXRpbmdcbiAgdmFyIHF1ZXJ5ID0ge3NlY3JldDogc2VjcmV0fTtcbiAgaWYgKGlzc3VlcikgcXVlcnkuaXNzdWVyID0gaXNzdWVyO1xuXG4gIC8vIHZhbGlkYXRlIGFsZ29yaXRobVxuICBpZiAoYWxnb3JpdGhtICE9IG51bGwpIHtcbiAgICBzd2l0Y2ggKGFsZ29yaXRobS50b1VwcGVyQ2FzZSgpKSB7XG4gICAgICBjYXNlICdTSEExJzpcbiAgICAgIGNhc2UgJ1NIQTI1Nic6XG4gICAgICBjYXNlICdTSEE1MTInOlxuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGNvbnNvbGUud2FybignU3BlYWtlYXN5IC0gb3RwYXV0aFVSTCAtIFdhcm5pbmcgLSBBbGdvcml0aG0gZ2VuZXJhbGx5IHNob3VsZCBiZSBTSEExLCBTSEEyNTYsIG9yIFNIQTUxMicpO1xuICAgIH1cbiAgICBxdWVyeS5hbGdvcml0aG0gPSBhbGdvcml0aG0udG9VcHBlckNhc2UoKTtcbiAgfVxuXG4gIC8vIHZhbGlkYXRlIGRpZ2l0c1xuICBpZiAoZGlnaXRzICE9IG51bGwpIHtcbiAgICBpZiAoaXNOYU4oZGlnaXRzKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTcGVha2Vhc3kgLSBvdHBhdXRoVVJMIC0gSW52YWxpZCBkaWdpdHMgYCcgKyBkaWdpdHMgKyAnYCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzd2l0Y2ggKHBhcnNlSW50KGRpZ2l0cywgMTApKSB7XG4gICAgICAgIGNhc2UgNjpcbiAgICAgICAgY2FzZSA4OlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGNvbnNvbGUud2FybignU3BlYWtlYXN5IC0gb3RwYXV0aFVSTCAtIFdhcm5pbmcgLSBEaWdpdHMgZ2VuZXJhbGx5IHNob3VsZCBiZSBlaXRoZXIgNiBvciA4Jyk7XG4gICAgICB9XG4gICAgfVxuICAgIHF1ZXJ5LmRpZ2l0cyA9IGRpZ2l0cztcbiAgfVxuXG4gIC8vIHZhbGlkYXRlIHBlcmlvZFxuICBpZiAocGVyaW9kICE9IG51bGwpIHtcbiAgICBwZXJpb2QgPSBwYXJzZUludChwZXJpb2QsIDEwKTtcbiAgICBpZiAofn5wZXJpb2QgIT09IHBlcmlvZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTcGVha2Vhc3kgLSBvdHBhdXRoVVJMIC0gSW52YWxpZCBwZXJpb2QgYCcgKyBwZXJpb2QgKyAnYCcpO1xuICAgIH1cbiAgICBxdWVyeS5wZXJpb2QgPSBwZXJpb2Q7XG4gIH1cblxuICAvLyByZXR1cm4gdXJsXG4gIHJldHVybiB1cmwuZm9ybWF0KHtcbiAgICBwcm90b2NvbDogJ290cGF1dGgnLFxuICAgIHNsYXNoZXM6IHRydWUsXG4gICAgaG9zdG5hbWU6IHR5cGUsXG4gICAgcGF0aG5hbWU6IGxhYmVsLFxuICAgIHF1ZXJ5OiBxdWVyeVxuICB9KTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/speakeasy/index.js\n");

/***/ })

};
;