"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/base32.js";
exports.ids = ["vendor-chunks/base32.js"];
exports.modules = {

/***/ "(rsc)/./node_modules/base32.js/base32.js":
/*!******************************************!*\
  !*** ./node_modules/base32.js/base32.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n\n/**\n * Generate a character map.\n * @param {string} alphabet e.g. \"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567\"\n * @param {object} mappings map overrides from key to value\n * @method\n */\n\nvar charmap = function (alphabet, mappings) {\n  mappings || (mappings = {});\n  alphabet.split(\"\").forEach(function (c, i) {\n    if (!(c in mappings)) mappings[c] = i;\n  });\n  return mappings;\n}\n\n/**\n * The RFC 4648 base 32 alphabet and character map.\n * @see {@link https://tools.ietf.org/html/rfc4648}\n */\n\nvar rfc4648 = {\n  alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567\",\n  charmap: {\n    0: 14,\n    1: 8\n  }\n};\n\nrfc4648.charmap = charmap(rfc4648.alphabet, rfc4648.charmap);\n\n/**\n * The Crockford base 32 alphabet and character map.\n * @see {@link http://www.crockford.com/wrmg/base32.html}\n */\n\nvar crockford = {\n  alphabet: \"0123456789ABCDEFGHJKMNPQRSTVWXYZ\",\n  charmap: {\n    O: 0,\n    I: 1,\n    L: 1\n  }\n};\n\ncrockford.charmap = charmap(crockford.alphabet, crockford.charmap);\n\n/**\n * Create a new `Decoder` with the given options.\n *\n * @param {object} [options]\n *   @param {string} [type] Supported Base-32 variants are \"rfc4648\" and\n *     \"crockford\".\n *   @param {object} [charmap] Override the character map used in decoding.\n */\n\nfunction Decoder (options) {\n  this.buf = [];\n  this.shift = 8;\n  this.carry = 0;\n\n  if (options) {\n\n    switch (options.type) {\n      case \"rfc4648\":\n        this.charmap = exports.rfc4648.charmap;\n        break;\n      case \"crockford\":\n        this.charmap = exports.crockford.charmap;\n        break;\n      default:\n        throw new Error(\"invalid type\");\n    }\n\n    if (options.charmap) this.charmap = options.charmap;\n  }\n}\n\n/**\n * The default character map coresponds to RFC4648.\n */\n\nDecoder.prototype.charmap = rfc4648.charmap;\n\n/**\n * Decode a string, continuing from the previous state.\n *\n * @param {string} str\n * @return {Decoder} this\n */\n\nDecoder.prototype.write = function (str) {\n  var charmap = this.charmap;\n  var buf = this.buf;\n  var shift = this.shift;\n  var carry = this.carry;\n\n  // decode string\n  str.toUpperCase().split(\"\").forEach(function (char) {\n\n    // ignore padding\n    if (char == \"=\") return;\n\n    // lookup symbol\n    var symbol = charmap[char] & 0xff;\n\n    // 1: 00000 000\n    // 2:          00 00000 0\n    // 3:                    0000 0000\n    // 4:                             0 00000 00\n    // 5:                                       000 00000\n    // 6:                                                00000 000\n    // 7:                                                         00 00000 0\n\n    shift -= 5;\n    if (shift > 0) {\n      carry |= symbol << shift;\n    } else if (shift < 0) {\n      buf.push(carry | (symbol >> -shift));\n      shift += 8;\n      carry = (symbol << shift) & 0xff;\n    } else {\n      buf.push(carry | symbol);\n      shift = 8;\n      carry = 0;\n    }\n  });\n\n  // save state\n  this.shift = shift;\n  this.carry = carry;\n\n  // for chaining\n  return this;\n};\n\n/**\n * Finish decoding.\n *\n * @param {string} [str] The final string to decode.\n * @return {Array} Decoded byte array.\n */\n\nDecoder.prototype.finalize = function (str) {\n  if (str) {\n    this.write(str);\n  }\n  if (this.shift !== 8 && this.carry !== 0) {\n    this.buf.push(this.carry);\n    this.shift = 8;\n    this.carry = 0;\n  }\n  return this.buf;\n};\n\n/**\n * Create a new `Encoder` with the given options.\n *\n * @param {object} [options]\n *   @param {string} [type] Supported Base-32 variants are \"rfc4648\" and\n *     \"crockford\".\n *   @param {object} [alphabet] Override the alphabet used in encoding.\n */\n\nfunction Encoder (options) {\n  this.buf = \"\";\n  this.shift = 3;\n  this.carry = 0;\n\n  if (options) {\n\n    switch (options.type) {\n      case \"rfc4648\":\n        this.alphabet = exports.rfc4648.alphabet;\n        break;\n      case \"crockford\":\n        this.alphabet = exports.crockford.alphabet;\n        break;\n      default:\n        throw new Error(\"invalid type\");\n    }\n\n    if (options.alphabet) this.alphabet = options.alphabet;\n    else if (options.lc) this.alphabet = this.alphabet.toLowerCase();\n  }\n}\n\n/**\n * The default alphabet coresponds to RFC4648.\n */\n\nEncoder.prototype.alphabet = rfc4648.alphabet;\n\n/**\n * Encode a byte array, continuing from the previous state.\n *\n * @param {byte[]} buf The byte array to encode.\n * @return {Encoder} this\n */\n\nEncoder.prototype.write = function (buf) {\n  var shift = this.shift;\n  var carry = this.carry;\n  var symbol;\n  var byte;\n  var i;\n\n  // encode each byte in buf\n  for (i = 0; i < buf.length; i++) {\n    byte = buf[i];\n\n    // 1: 00000 000\n    // 2:          00 00000 0\n    // 3:                    0000 0000\n    // 4:                             0 00000 00\n    // 5:                                       000 00000\n    // 6:                                                00000 000\n    // 7:                                                         00 00000 0\n\n    symbol = carry | (byte >> shift);\n    this.buf += this.alphabet[symbol & 0x1f];\n\n    if (shift > 5) {\n      shift -= 5;\n      symbol = byte >> shift;\n      this.buf += this.alphabet[symbol & 0x1f];\n    }\n\n    shift = 5 - shift;\n    carry = byte << shift;\n    shift = 8 - shift;\n  }\n\n  // save state\n  this.shift = shift;\n  this.carry = carry;\n\n  // for chaining\n  return this;\n};\n\n/**\n * Finish encoding.\n *\n * @param {byte[]} [buf] The final byte array to encode.\n * @return {string} The encoded byte array.\n */\n\nEncoder.prototype.finalize = function (buf) {\n  if (buf) {\n    this.write(buf);\n  }\n  if (this.shift !== 3) {\n    this.buf += this.alphabet[this.carry & 0x1f];\n    this.shift = 3;\n    this.carry = 0;\n  }\n  return this.buf;\n};\n\n/**\n * Convenience encoder.\n *\n * @param {byte[]} buf The byte array to encode.\n * @param {object} [options] Options to pass to the encoder.\n * @return {string} The encoded string.\n */\n\nexports.encode = function (buf, options) {\n  return new Encoder(options).finalize(buf);\n};\n\n/**\n * Convenience decoder.\n *\n * @param {string} str The string to decode.\n * @param {object} [options] Options to pass to the decoder.\n * @return {byte[]} The decoded byte array.\n */\n\nexports.decode = function (str, options) {\n  return new Decoder(options).finalize(str);\n};\n\n// Exports.\nexports.Decoder = Decoder;\nexports.Encoder = Encoder;\nexports.charmap = charmap;\nexports.crockford = crockford;\nexports.rfc4648 = rfc4648;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYmFzZTMyLmpzL2Jhc2UzMi5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVksU0FBUztBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVksT0FBTztBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLFFBQVE7QUFDckI7QUFDQSxhQUFhLFFBQVE7QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZLFNBQVM7QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYyxnQkFBZ0I7QUFDOUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVksUUFBUTtBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsWUFBWSxRQUFRO0FBQ3BCOztBQUVBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsWUFBWSxRQUFRO0FBQ3BCOztBQUVBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0EsZUFBZTtBQUNmLGVBQWU7QUFDZixlQUFlO0FBQ2YsaUJBQWlCO0FBQ2pCLGVBQWUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lY29tbWVyY2Utb3V0c2V0Ly4vbm9kZV9tb2R1bGVzL2Jhc2UzMi5qcy9iYXNlMzIuanM/YTRkNiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBHZW5lcmF0ZSBhIGNoYXJhY3RlciBtYXAuXG4gKiBAcGFyYW0ge3N0cmluZ30gYWxwaGFiZXQgZS5nLiBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaMjM0NTY3XCJcbiAqIEBwYXJhbSB7b2JqZWN0fSBtYXBwaW5ncyBtYXAgb3ZlcnJpZGVzIGZyb20ga2V5IHRvIHZhbHVlXG4gKiBAbWV0aG9kXG4gKi9cblxudmFyIGNoYXJtYXAgPSBmdW5jdGlvbiAoYWxwaGFiZXQsIG1hcHBpbmdzKSB7XG4gIG1hcHBpbmdzIHx8IChtYXBwaW5ncyA9IHt9KTtcbiAgYWxwaGFiZXQuc3BsaXQoXCJcIikuZm9yRWFjaChmdW5jdGlvbiAoYywgaSkge1xuICAgIGlmICghKGMgaW4gbWFwcGluZ3MpKSBtYXBwaW5nc1tjXSA9IGk7XG4gIH0pO1xuICByZXR1cm4gbWFwcGluZ3M7XG59XG5cbi8qKlxuICogVGhlIFJGQyA0NjQ4IGJhc2UgMzIgYWxwaGFiZXQgYW5kIGNoYXJhY3RlciBtYXAuXG4gKiBAc2VlIHtAbGluayBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNDY0OH1cbiAqL1xuXG52YXIgcmZjNDY0OCA9IHtcbiAgYWxwaGFiZXQ6IFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVoyMzQ1NjdcIixcbiAgY2hhcm1hcDoge1xuICAgIDA6IDE0LFxuICAgIDE6IDhcbiAgfVxufTtcblxucmZjNDY0OC5jaGFybWFwID0gY2hhcm1hcChyZmM0NjQ4LmFscGhhYmV0LCByZmM0NjQ4LmNoYXJtYXApO1xuXG4vKipcbiAqIFRoZSBDcm9ja2ZvcmQgYmFzZSAzMiBhbHBoYWJldCBhbmQgY2hhcmFjdGVyIG1hcC5cbiAqIEBzZWUge0BsaW5rIGh0dHA6Ly93d3cuY3JvY2tmb3JkLmNvbS93cm1nL2Jhc2UzMi5odG1sfVxuICovXG5cbnZhciBjcm9ja2ZvcmQgPSB7XG4gIGFscGhhYmV0OiBcIjAxMjM0NTY3ODlBQkNERUZHSEpLTU5QUVJTVFZXWFlaXCIsXG4gIGNoYXJtYXA6IHtcbiAgICBPOiAwLFxuICAgIEk6IDEsXG4gICAgTDogMVxuICB9XG59O1xuXG5jcm9ja2ZvcmQuY2hhcm1hcCA9IGNoYXJtYXAoY3JvY2tmb3JkLmFscGhhYmV0LCBjcm9ja2ZvcmQuY2hhcm1hcCk7XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IGBEZWNvZGVyYCB3aXRoIHRoZSBnaXZlbiBvcHRpb25zLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc11cbiAqICAgQHBhcmFtIHtzdHJpbmd9IFt0eXBlXSBTdXBwb3J0ZWQgQmFzZS0zMiB2YXJpYW50cyBhcmUgXCJyZmM0NjQ4XCIgYW5kXG4gKiAgICAgXCJjcm9ja2ZvcmRcIi5cbiAqICAgQHBhcmFtIHtvYmplY3R9IFtjaGFybWFwXSBPdmVycmlkZSB0aGUgY2hhcmFjdGVyIG1hcCB1c2VkIGluIGRlY29kaW5nLlxuICovXG5cbmZ1bmN0aW9uIERlY29kZXIgKG9wdGlvbnMpIHtcbiAgdGhpcy5idWYgPSBbXTtcbiAgdGhpcy5zaGlmdCA9IDg7XG4gIHRoaXMuY2FycnkgPSAwO1xuXG4gIGlmIChvcHRpb25zKSB7XG5cbiAgICBzd2l0Y2ggKG9wdGlvbnMudHlwZSkge1xuICAgICAgY2FzZSBcInJmYzQ2NDhcIjpcbiAgICAgICAgdGhpcy5jaGFybWFwID0gZXhwb3J0cy5yZmM0NjQ4LmNoYXJtYXA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImNyb2NrZm9yZFwiOlxuICAgICAgICB0aGlzLmNoYXJtYXAgPSBleHBvcnRzLmNyb2NrZm9yZC5jaGFybWFwO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgdHlwZVwiKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5jaGFybWFwKSB0aGlzLmNoYXJtYXAgPSBvcHRpb25zLmNoYXJtYXA7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGUgZGVmYXVsdCBjaGFyYWN0ZXIgbWFwIGNvcmVzcG9uZHMgdG8gUkZDNDY0OC5cbiAqL1xuXG5EZWNvZGVyLnByb3RvdHlwZS5jaGFybWFwID0gcmZjNDY0OC5jaGFybWFwO1xuXG4vKipcbiAqIERlY29kZSBhIHN0cmluZywgY29udGludWluZyBmcm9tIHRoZSBwcmV2aW91cyBzdGF0ZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtEZWNvZGVyfSB0aGlzXG4gKi9cblxuRGVjb2Rlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoc3RyKSB7XG4gIHZhciBjaGFybWFwID0gdGhpcy5jaGFybWFwO1xuICB2YXIgYnVmID0gdGhpcy5idWY7XG4gIHZhciBzaGlmdCA9IHRoaXMuc2hpZnQ7XG4gIHZhciBjYXJyeSA9IHRoaXMuY2Fycnk7XG5cbiAgLy8gZGVjb2RlIHN0cmluZ1xuICBzdHIudG9VcHBlckNhc2UoKS5zcGxpdChcIlwiKS5mb3JFYWNoKGZ1bmN0aW9uIChjaGFyKSB7XG5cbiAgICAvLyBpZ25vcmUgcGFkZGluZ1xuICAgIGlmIChjaGFyID09IFwiPVwiKSByZXR1cm47XG5cbiAgICAvLyBsb29rdXAgc3ltYm9sXG4gICAgdmFyIHN5bWJvbCA9IGNoYXJtYXBbY2hhcl0gJiAweGZmO1xuXG4gICAgLy8gMTogMDAwMDAgMDAwXG4gICAgLy8gMjogICAgICAgICAgMDAgMDAwMDAgMFxuICAgIC8vIDM6ICAgICAgICAgICAgICAgICAgICAwMDAwIDAwMDBcbiAgICAvLyA0OiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMCAwMDAwMCAwMFxuICAgIC8vIDU6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMDAwIDAwMDAwXG4gICAgLy8gNjogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAwMDAwMCAwMDBcbiAgICAvLyA3OiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDAwIDAwMDAwIDBcblxuICAgIHNoaWZ0IC09IDU7XG4gICAgaWYgKHNoaWZ0ID4gMCkge1xuICAgICAgY2FycnkgfD0gc3ltYm9sIDw8IHNoaWZ0O1xuICAgIH0gZWxzZSBpZiAoc2hpZnQgPCAwKSB7XG4gICAgICBidWYucHVzaChjYXJyeSB8IChzeW1ib2wgPj4gLXNoaWZ0KSk7XG4gICAgICBzaGlmdCArPSA4O1xuICAgICAgY2FycnkgPSAoc3ltYm9sIDw8IHNoaWZ0KSAmIDB4ZmY7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJ1Zi5wdXNoKGNhcnJ5IHwgc3ltYm9sKTtcbiAgICAgIHNoaWZ0ID0gODtcbiAgICAgIGNhcnJ5ID0gMDtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIHNhdmUgc3RhdGVcbiAgdGhpcy5zaGlmdCA9IHNoaWZ0O1xuICB0aGlzLmNhcnJ5ID0gY2Fycnk7XG5cbiAgLy8gZm9yIGNoYWluaW5nXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBGaW5pc2ggZGVjb2RpbmcuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IFtzdHJdIFRoZSBmaW5hbCBzdHJpbmcgdG8gZGVjb2RlLlxuICogQHJldHVybiB7QXJyYXl9IERlY29kZWQgYnl0ZSBhcnJheS5cbiAqL1xuXG5EZWNvZGVyLnByb3RvdHlwZS5maW5hbGl6ZSA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgaWYgKHN0cikge1xuICAgIHRoaXMud3JpdGUoc3RyKTtcbiAgfVxuICBpZiAodGhpcy5zaGlmdCAhPT0gOCAmJiB0aGlzLmNhcnJ5ICE9PSAwKSB7XG4gICAgdGhpcy5idWYucHVzaCh0aGlzLmNhcnJ5KTtcbiAgICB0aGlzLnNoaWZ0ID0gODtcbiAgICB0aGlzLmNhcnJ5ID0gMDtcbiAgfVxuICByZXR1cm4gdGhpcy5idWY7XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBgRW5jb2RlcmAgd2l0aCB0aGUgZ2l2ZW4gb3B0aW9ucy5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXG4gKiAgIEBwYXJhbSB7c3RyaW5nfSBbdHlwZV0gU3VwcG9ydGVkIEJhc2UtMzIgdmFyaWFudHMgYXJlIFwicmZjNDY0OFwiIGFuZFxuICogICAgIFwiY3JvY2tmb3JkXCIuXG4gKiAgIEBwYXJhbSB7b2JqZWN0fSBbYWxwaGFiZXRdIE92ZXJyaWRlIHRoZSBhbHBoYWJldCB1c2VkIGluIGVuY29kaW5nLlxuICovXG5cbmZ1bmN0aW9uIEVuY29kZXIgKG9wdGlvbnMpIHtcbiAgdGhpcy5idWYgPSBcIlwiO1xuICB0aGlzLnNoaWZ0ID0gMztcbiAgdGhpcy5jYXJyeSA9IDA7XG5cbiAgaWYgKG9wdGlvbnMpIHtcblxuICAgIHN3aXRjaCAob3B0aW9ucy50eXBlKSB7XG4gICAgICBjYXNlIFwicmZjNDY0OFwiOlxuICAgICAgICB0aGlzLmFscGhhYmV0ID0gZXhwb3J0cy5yZmM0NjQ4LmFscGhhYmV0O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJjcm9ja2ZvcmRcIjpcbiAgICAgICAgdGhpcy5hbHBoYWJldCA9IGV4cG9ydHMuY3JvY2tmb3JkLmFscGhhYmV0O1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgdHlwZVwiKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5hbHBoYWJldCkgdGhpcy5hbHBoYWJldCA9IG9wdGlvbnMuYWxwaGFiZXQ7XG4gICAgZWxzZSBpZiAob3B0aW9ucy5sYykgdGhpcy5hbHBoYWJldCA9IHRoaXMuYWxwaGFiZXQudG9Mb3dlckNhc2UoKTtcbiAgfVxufVxuXG4vKipcbiAqIFRoZSBkZWZhdWx0IGFscGhhYmV0IGNvcmVzcG9uZHMgdG8gUkZDNDY0OC5cbiAqL1xuXG5FbmNvZGVyLnByb3RvdHlwZS5hbHBoYWJldCA9IHJmYzQ2NDguYWxwaGFiZXQ7XG5cbi8qKlxuICogRW5jb2RlIGEgYnl0ZSBhcnJheSwgY29udGludWluZyBmcm9tIHRoZSBwcmV2aW91cyBzdGF0ZS5cbiAqXG4gKiBAcGFyYW0ge2J5dGVbXX0gYnVmIFRoZSBieXRlIGFycmF5IHRvIGVuY29kZS5cbiAqIEByZXR1cm4ge0VuY29kZXJ9IHRoaXNcbiAqL1xuXG5FbmNvZGVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChidWYpIHtcbiAgdmFyIHNoaWZ0ID0gdGhpcy5zaGlmdDtcbiAgdmFyIGNhcnJ5ID0gdGhpcy5jYXJyeTtcbiAgdmFyIHN5bWJvbDtcbiAgdmFyIGJ5dGU7XG4gIHZhciBpO1xuXG4gIC8vIGVuY29kZSBlYWNoIGJ5dGUgaW4gYnVmXG4gIGZvciAoaSA9IDA7IGkgPCBidWYubGVuZ3RoOyBpKyspIHtcbiAgICBieXRlID0gYnVmW2ldO1xuXG4gICAgLy8gMTogMDAwMDAgMDAwXG4gICAgLy8gMjogICAgICAgICAgMDAgMDAwMDAgMFxuICAgIC8vIDM6ICAgICAgICAgICAgICAgICAgICAwMDAwIDAwMDBcbiAgICAvLyA0OiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMCAwMDAwMCAwMFxuICAgIC8vIDU6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMDAwIDAwMDAwXG4gICAgLy8gNjogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAwMDAwMCAwMDBcbiAgICAvLyA3OiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDAwIDAwMDAwIDBcblxuICAgIHN5bWJvbCA9IGNhcnJ5IHwgKGJ5dGUgPj4gc2hpZnQpO1xuICAgIHRoaXMuYnVmICs9IHRoaXMuYWxwaGFiZXRbc3ltYm9sICYgMHgxZl07XG5cbiAgICBpZiAoc2hpZnQgPiA1KSB7XG4gICAgICBzaGlmdCAtPSA1O1xuICAgICAgc3ltYm9sID0gYnl0ZSA+PiBzaGlmdDtcbiAgICAgIHRoaXMuYnVmICs9IHRoaXMuYWxwaGFiZXRbc3ltYm9sICYgMHgxZl07XG4gICAgfVxuXG4gICAgc2hpZnQgPSA1IC0gc2hpZnQ7XG4gICAgY2FycnkgPSBieXRlIDw8IHNoaWZ0O1xuICAgIHNoaWZ0ID0gOCAtIHNoaWZ0O1xuICB9XG5cbiAgLy8gc2F2ZSBzdGF0ZVxuICB0aGlzLnNoaWZ0ID0gc2hpZnQ7XG4gIHRoaXMuY2FycnkgPSBjYXJyeTtcblxuICAvLyBmb3IgY2hhaW5pbmdcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEZpbmlzaCBlbmNvZGluZy5cbiAqXG4gKiBAcGFyYW0ge2J5dGVbXX0gW2J1Zl0gVGhlIGZpbmFsIGJ5dGUgYXJyYXkgdG8gZW5jb2RlLlxuICogQHJldHVybiB7c3RyaW5nfSBUaGUgZW5jb2RlZCBieXRlIGFycmF5LlxuICovXG5cbkVuY29kZXIucHJvdG90eXBlLmZpbmFsaXplID0gZnVuY3Rpb24gKGJ1Zikge1xuICBpZiAoYnVmKSB7XG4gICAgdGhpcy53cml0ZShidWYpO1xuICB9XG4gIGlmICh0aGlzLnNoaWZ0ICE9PSAzKSB7XG4gICAgdGhpcy5idWYgKz0gdGhpcy5hbHBoYWJldFt0aGlzLmNhcnJ5ICYgMHgxZl07XG4gICAgdGhpcy5zaGlmdCA9IDM7XG4gICAgdGhpcy5jYXJyeSA9IDA7XG4gIH1cbiAgcmV0dXJuIHRoaXMuYnVmO1xufTtcblxuLyoqXG4gKiBDb252ZW5pZW5jZSBlbmNvZGVyLlxuICpcbiAqIEBwYXJhbSB7Ynl0ZVtdfSBidWYgVGhlIGJ5dGUgYXJyYXkgdG8gZW5jb2RlLlxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIHRvIHBhc3MgdG8gdGhlIGVuY29kZXIuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBlbmNvZGVkIHN0cmluZy5cbiAqL1xuXG5leHBvcnRzLmVuY29kZSA9IGZ1bmN0aW9uIChidWYsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIG5ldyBFbmNvZGVyKG9wdGlvbnMpLmZpbmFsaXplKGJ1Zik7XG59O1xuXG4vKipcbiAqIENvbnZlbmllbmNlIGRlY29kZXIuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0ciBUaGUgc3RyaW5nIHRvIGRlY29kZS5cbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyB0byBwYXNzIHRvIHRoZSBkZWNvZGVyLlxuICogQHJldHVybiB7Ynl0ZVtdfSBUaGUgZGVjb2RlZCBieXRlIGFycmF5LlxuICovXG5cbmV4cG9ydHMuZGVjb2RlID0gZnVuY3Rpb24gKHN0ciwgb3B0aW9ucykge1xuICByZXR1cm4gbmV3IERlY29kZXIob3B0aW9ucykuZmluYWxpemUoc3RyKTtcbn07XG5cbi8vIEV4cG9ydHMuXG5leHBvcnRzLkRlY29kZXIgPSBEZWNvZGVyO1xuZXhwb3J0cy5FbmNvZGVyID0gRW5jb2RlcjtcbmV4cG9ydHMuY2hhcm1hcCA9IGNoYXJtYXA7XG5leHBvcnRzLmNyb2NrZm9yZCA9IGNyb2NrZm9yZDtcbmV4cG9ydHMucmZjNDY0OCA9IHJmYzQ2NDg7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/base32.js/base32.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/base32.js/index.js":
/*!*****************************************!*\
  !*** ./node_modules/base32.js/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\n// Module dependencies.\nvar base32 = __webpack_require__(/*! ./base32 */ \"(rsc)/./node_modules/base32.js/base32.js\");\n\n\n// Wrap decoder finalize to return a buffer;\nvar finalizeDecode = base32.Decoder.prototype.finalize;\nbase32.Decoder.prototype.finalize = function (buf) {\n  var bytes = finalizeDecode.call(this, buf);\n  return new Buffer(bytes);\n};\n\n\n// Export Base32.\nmodule.exports = base32;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYmFzZTMyLmpzL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0EsYUFBYSxtQkFBTyxDQUFDLDBEQUFVOzs7QUFHL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZWNvbW1lcmNlLW91dHNldC8uL25vZGVfbW9kdWxlcy9iYXNlMzIuanMvaW5kZXguanM/ZmMyOSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuLy8gTW9kdWxlIGRlcGVuZGVuY2llcy5cbnZhciBiYXNlMzIgPSByZXF1aXJlKFwiLi9iYXNlMzJcIik7XG5cblxuLy8gV3JhcCBkZWNvZGVyIGZpbmFsaXplIHRvIHJldHVybiBhIGJ1ZmZlcjtcbnZhciBmaW5hbGl6ZURlY29kZSA9IGJhc2UzMi5EZWNvZGVyLnByb3RvdHlwZS5maW5hbGl6ZTtcbmJhc2UzMi5EZWNvZGVyLnByb3RvdHlwZS5maW5hbGl6ZSA9IGZ1bmN0aW9uIChidWYpIHtcbiAgdmFyIGJ5dGVzID0gZmluYWxpemVEZWNvZGUuY2FsbCh0aGlzLCBidWYpO1xuICByZXR1cm4gbmV3IEJ1ZmZlcihieXRlcyk7XG59O1xuXG5cbi8vIEV4cG9ydCBCYXNlMzIuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2UzMjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/base32.js/index.js\n");

/***/ })

};
;